<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core · VPL.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VPL.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">User Manual</span><ul><li><a class="tocitem" href="../manual/VPL.html">Dynamic graph creation and manipulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/01_algae.html">Algae growth</a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href="Core.html">Core</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Applying-rules-and-queries"><span>Applying rules and queries</span></a></li><li><a class="tocitem" href="#Extracting-information"><span>Extracting information</span></a></li><li><a class="tocitem" href="#Graph-traversal"><span>Graph traversal</span></a></li><li><a class="tocitem" href="#Graph-visualization"><span>Graph visualization</span></a></li></ul></li></ul></li><li><span class="tocitem">Technical Notes</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="Core.html">Core</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Core.html">Core</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Module-Core"><a class="docs-heading-anchor" href="#Module-Core">Module Core</a><a id="Module-Core-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Core" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.Graph" href="#VPL.Core.Graph"><code>VPL.Core.Graph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Graph(axiom; rules = nothing, vars = nothing)</p><p>Creates a dynamic graph defined by the initial node or nodes (<code>axiom</code>), one or more rules  (<code>rules</code>), and an object with graph-level variables (<code>vars</code>). Rules and graph-level variables are optional and must be assigned by keyword (see example below).  Rules must be an <code>Rule</code> or tuple of <code>Rule</code> objects.  The <code>axiom</code> may be a single object inheriting from <code>Node</code> or a subgraph generated  with the graph construction DSL.  A copy of the axiom and rules is always made when constructing the graph, but if object containing graph-level variables is not <code>mutable</code>, the user must manually copy (with <code>copy</code> or <code>deepcopy</code>) or else changes within the graph will affect the original object (and other graphs creates from the same object).</p><p><strong>Example</strong></p><pre><code class="language-julia">struct A &lt;: Node end
struct B &lt;: Node end
axiom = A() + B()
no_rules_graph = Graph(axiom)
rule = Rule(A, rhs = x -&gt; A() + B())
rules_graph = Graph(axiom, rules = rule)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.Rule" href="#VPL.Core.Rule"><code>VPL.Core.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rule(nodetype; lhs = x -&gt; true, rhs = x -&gt; nothing, captures = false)</p><p>Create a replacement rule for nodes of type <code>nodetype</code> with function-like objects for the left-hand side (<code>lhs</code>) and right-hand side (<code>rhs</code>). If the rule captures nodes in the context of the replacement node this must be indicated by the argument <code>captures</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">struct A &lt;: Node end
struct B &lt;: Node end
axiom = A() + B()
rule = Rule(A, rhs = x -&gt; A() + B())
rules_graph = Graph(axiom, rules = rule)
rewrite!(rules_graph)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.Query" href="#VPL.Core.Query"><code>VPL.Core.Query</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Query(nodetype::DataType, query = x -&gt; true)</p><p>Create a query that matches nodes of type <code>nodetype</code> and the conditions specified in the argument <code>query</code> (must be a function that returns <code>true</code>). It returns an object of type <code>Query</code> that can be applied to a graph with the function <code>apply</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">struct A &lt;: Node end
struct B &lt;: Node end
axiom = A() + B()
graph = Graph(axiom)
query = Query(A)
apply(graph, query)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.Node" href="#VPL.Core.Node"><code>VPL.Core.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Node</p><p>Abstract type from which every node in a graph should inherit. This allows using the graph construction DSL</p><p><strong>Example</strong></p><pre><code class="language-julia">struct bar &lt;: Node
  x::Int
end
b1 = bar(1)
b2 = bar(2)
b1 + b2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.Context" href="#VPL.Core.Context"><code>VPL.Core.Context</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Context</p><p>Data structure than links a <code>GraphNode</code> to a <code>Graph</code>. Functions <code>data</code> and <code>vars</code>  give access to the data stored in the node and graph, respectively. Several  methods are also available to test relationships among nodes in the graph and to  extract these related nodes (see User Manual for details).</p><p>Uses do not build <code>Context</code> objects directly but they are provided by VPL as  inputs to the user-defined functions inside rules and queries. </p></div></section></article><h2 id="Applying-rules-and-queries"><a class="docs-heading-anchor" href="#Applying-rules-and-queries">Applying rules and queries</a><a id="Applying-rules-and-queries-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-rules-and-queries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.apply-Tuple{VPL.Core.Graph, VPL.Core.Query}" href="#VPL.Core.apply-Tuple{VPL.Core.Graph, VPL.Core.Query}"><code>VPL.Core.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><p>apply(g::Graph, query::Query)</p><p>Return an array with all the nodes in the graph that match the query supplied by  the user.</p><p><strong>Example</strong></p><pre><code class="language-julia">struct A &lt;: Node end
struct B &lt;: Node end
axiom = A() + B()
graph = Graph(axiom)
query = Query(A)
apply(graph, query)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.rewrite!-Tuple{VPL.Core.Graph}" href="#VPL.Core.rewrite!-Tuple{VPL.Core.Graph}"><code>VPL.Core.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rewrite!(g::Graph)</code></pre><p>Apply the graph-rewriting rules stored in the graph. This function will match the left-hand sides of the rules against the graph and then replace and/or prune the graph at every location where the left-hand sides matched by the result of executing the right hand side of each rule. The modification is performed in-place, so this function returns <code>nothing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">struct A &lt;: Node end
struct B &lt;: Node end
axiom = A() + B()
rule = Rule(A, rhs = x -&gt; A() + B())
rules_graph = Graph(axiom, rules = rule)
rewrite!(rules_graph)</code></pre></div></section></article><h2 id="Extracting-information"><a class="docs-heading-anchor" href="#Extracting-information">Extracting information</a><a id="Extracting-information-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.vars-Tuple{VPL.Core.Graph}" href="#VPL.Core.vars-Tuple{VPL.Core.Graph}"><code>VPL.Core.vars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>vars(g::Graph)</p><p>Returns the object storing the graph-level variables</p><p><strong>Example</strong></p><pre><code class="language-julia">struct A &lt;: Node end
axiom = A()
graph = Graph(axiom, vars = 2)
vars(graph)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.rules-Tuple{VPL.Core.Graph}" href="#VPL.Core.rules-Tuple{VPL.Core.Graph}"><code>VPL.Core.rules</code></a> — <span class="docstring-category">Method</span></header><section><div><p>rules(g::Graph)</p><p>Returns a tuple with all the graph-rewriting rules stored in the graph</p><p><strong>Example</strong></p><pre><code class="language-julia">struct A &lt;: Node end
struct B &lt;: Node end
axiom = A() + B()
rule = Rule(A, rhs = x -&gt; A() + B())
rules_graph = Graph(axiom, rules = rule)
rules(rules_graph)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.vars-Tuple{VPL.Core.Context}" href="#VPL.Core.vars-Tuple{VPL.Core.Context}"><code>VPL.Core.vars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>vars(c::Context)</p><p>Returns the object storing the graph-level variables in the graph associated to  a <code>Context</code> object. This needs to be used inside rules and queries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.data-Tuple{VPL.Core.Context}" href="#VPL.Core.data-Tuple{VPL.Core.Context}"><code>VPL.Core.data</code></a> — <span class="docstring-category">Method</span></header><section><div><p>data(c::Context)</p><p>Returns the data stored in the node associated to a <code>Context</code> object. This needs to be used inside rules and queries.</p></div></section></article><h2 id="Graph-traversal"><a class="docs-heading-anchor" href="#Graph-traversal">Graph traversal</a><a id="Graph-traversal-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-traversal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.hasParent-Tuple{VPL.Core.Context}" href="#VPL.Core.hasParent-Tuple{VPL.Core.Context}"><code>VPL.Core.hasParent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hasParent(c::Context)</code></pre><p>Check if the node passed as argument has a parent and return <code>true</code> or <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.isRoot-Tuple{VPL.Core.Context}" href="#VPL.Core.isRoot-Tuple{VPL.Core.Context}"><code>VPL.Core.isRoot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isRoot(c::Context)</code></pre><p>Check if the node passed as argument is the root of the graph (i.e. has no parent)  and return <code>true</code> or <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.hasAncestor" href="#VPL.Core.hasAncestor"><code>VPL.Core.hasAncestor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasAncestor(c::Context, condition, maxlevel)</code></pre><p>Check if the node passed as argument has an ancestor that matches the optional  condition and and return <code>true</code> or <code>false</code> and the number of steps taken.  The <code>argument</code> maxlevel is optional and limits the number of steps that the  algorithm will move through the graph (by default there is no limitation). The default condition returns <code>true</code> for any ancestor  and it takes an object of type <code>Context</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parent-Tuple{VPL.Core.Context}" href="#Base.parent-Tuple{VPL.Core.Context}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parent(c::Context, nsteps::Int)</code></pre><p>Returns a <code>Context</code> object associated to the parent of the node passed as first argument (<code>nsteps = 1</code>, the default) or an ancestor that is <code>nsteps</code> away from the node passed as first argument.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.ancestor" href="#VPL.Core.ancestor"><code>VPL.Core.ancestor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ancestor(c::Context, condition, maxlevel)</code></pre><p>Returns a <code>Context</code> object associated to the first ancestor of the node given as  argument that matches the optional condition. The <code>argument</code> maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a <code>Context</code> object. The default condition returns <code>true</code> for any ancestor and it takes an object of type <code>Context</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.hasChildren-Tuple{VPL.Core.Context}" href="#VPL.Core.hasChildren-Tuple{VPL.Core.Context}"><code>VPL.Core.hasChildren</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hasChildren(c::Context)</code></pre><p>Check if the node passed as argument has at least one child and return <code>true</code> or <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.isLeaf-Tuple{VPL.Core.Context}" href="#VPL.Core.isLeaf-Tuple{VPL.Core.Context}"><code>VPL.Core.isLeaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isLeaf(c::Context)</code></pre><p>Check if the node passed as argument is a leaf in the graph (i.e. has no children)  and return <code>true</code> or <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.hasDescendent" href="#VPL.Core.hasDescendent"><code>VPL.Core.hasDescendent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasDescendent(c::Context, condition, maxlevel)</code></pre><p>Check if the node passed as argument has a descendent that matches the optional condition and and return <code>true</code> or <code>false</code>. The <code>argument</code> maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The default condition returns <code>true</code> for any descendent  and it takes an object of type <code>Context</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.children-Tuple{VPL.Core.Context}" href="#VPL.Core.children-Tuple{VPL.Core.Context}"><code>VPL.Core.children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">children(c::Context)</code></pre><p>Returns a tuple of <code>Context</code> objects with all the children of thew node given as  argument.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.descendent" href="#VPL.Core.descendent"><code>VPL.Core.descendent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">descendent(c::Context, condition, maxlevel)</code></pre><p>Returns a <code>Context</code> object associated to the first descendent of the node given as  argument that matches the optional condition. The <code>argument</code> maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a <code>Context</code> object. The default condition returns <code>true</code> for any descendent and it takes an object of type <code>Context</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.traverse-Tuple{VPL.Core.Graph, Any}" href="#VPL.Core.traverse-Tuple{VPL.Core.Graph, Any}"><code>VPL.Core.traverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traverse(g::Graph, f)</code></pre><p>Iterates over all the nodes in the graph (in no particular order) and execute for each node the function <code>f</code> taking as input the data stored in the node.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.traverseDFS-Tuple{VPL.Core.Graph, Any}" href="#VPL.Core.traverseDFS-Tuple{VPL.Core.Graph, Any}"><code>VPL.Core.traverseDFS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traverseDFS(g::Graph, f)</code></pre><p>Iterates over all the nodes in the graph (depth-first order, starting at the  root of the graph) and execute for each node the function <code>f</code> taking as input the  data stored in the node.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.traverseBFS-Tuple{VPL.Core.Graph, Any}" href="#VPL.Core.traverseBFS-Tuple{VPL.Core.Graph, Any}"><code>VPL.Core.traverseBFS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traverseBFS(g::Graph, f)</code></pre><p>Iterates over all the nodes in the graph (breadth-first order, starting at the  root of the graph) and execute for each node the function <code>f</code> taking as input the  data stored in the node.</p></div></section></article><h2 id="Graph-visualization"><a class="docs-heading-anchor" href="#Graph-visualization">Graph visualization</a><a id="Graph-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-visualization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.draw-Tuple{VPL.Core.Graph}" href="#VPL.Core.draw-Tuple{VPL.Core.Graph}"><code>VPL.Core.draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">draw(g::Graph; name::String = &quot;VPL Graph&quot;)</code></pre><p>Draw a network representation of the graph. The drawing is performed on a <code>Blink</code> window using the vis.js Javascript library. The function returns the handler to the Blink window. Access to Internet is required as the libraries are loaded from the cdns server.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="VPL.Core.get_id-Tuple{Any, Any}" href="#VPL.Core.get_id-Tuple{Any, Any}"><code>VPL.Core.get_id</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_id(key, data)</p><p>Method that defines the label associated to the node <code>data</code> when drawing the graph. The argument <code>key</code> is the unique identifier of the node in the graph. The default method prints the type of data stored in the node and the unique identifier of the node in parenthesis.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/introduction/01_algae.html">« Algae growth</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 April 2021 09:25">Monday 12 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
