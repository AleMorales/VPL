var documenterSearchIndex = {"docs":
[{"location":"manual/VPL.html#Dynamic-graph-creation-and-manipulation","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"","category":"section"},{"location":"manual/VPL.html#Graphs,-Rules-and-Queries","page":"Dynamic graph creation and manipulation","title":"Graphs, Rules and Queries","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A model in VPL is a (discrete) dynamical model that describes the time evolution  of one or more entities (i.e. objects of type graph). Each graph  (usually  assumed to be an individual plant) is characterized by a series of nodes  (usually organs) that are represented by nodes in a graph. Each node is  defined by its own state, including (if applicable) a description of its geometry,  color, optical propertes, etc. The dynamic simulation of a graph consists of the  creation and destruction of nodes via graph rewriting rules, and changes to  the internal state of its nodes with the help of queries.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The 3D structure of a graph is generated by processing its nodes using a  Turtle procedural geometry approach (i.e. inspired on Logo's turtle graphs  as used in L-systems) and following the topology of the graph. This 3D structure  may be used for visualization using a 3D renderer or for simulating  spatial  processes.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL does not provide a domain-specific language to implement rules and queries.  Rather, they are defined by functions which are stored in objects of types Rule  and Query, respectively. Similarly, the nodes of a graph can be of any  user-defined type, as long as the user defines the necessary methods to support  specific functionality (e.g. the feedgeom! method to generate geometry).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL is designed around data types and methods. Building a model in VPL typically requires:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Defining types for the different classes of nodes of a graph\nCreating rules and queries based on these types\nCreating graphs by combining rules and the initial states of the graphs\nCreating additional elements in the scene (e.g. soil)","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A simulation in VPL consists of executing rules iteratively and, within each iteration:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Use queries to select subset of nodes and modify their states.\nModify graph-level variables directly.\nUse algorithms in VPL to simulate interactions among nodes or between","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"nodes and their environment.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In addition, VPL allows visualizing the results of a simulation by:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"3D rendering of the generated scenes\nNetwork graph representing the nodes in the graph","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL is designed to facilitate modular model development, such as using different  types of graphs in the same simulation, alternative visualizations of the same  scene by mapping internal states of nodes to colors, or including multiple  ray tracers in the same simulation. Users may also create their own data types  that include graphs as fields or to nest graphs within other graphs.","category":"page"},{"location":"manual/VPL.html#Graph","page":"Dynamic graph creation and manipulation","title":"Graph","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A graph is the basic unit of a model in VPL. Three types of data are stored  inside a graph:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Components of the graph.\nGraph rewriting rules.\nAn user-defined object that characterizes the state of a graph besides its ","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"nodes (i.e. graph-level variables).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The nodes of a graph are objects created by the user that inherit from the  abstract type Node. This abstract type enables describing the relationship  between nodes using a simple algebra for graph construction (see below). A  graph always needs to be initialized by at least one node (i.e. analogous  to the axiom of L-Systems), as otherwise graph rewriting rules could not be  applied.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The creation of a graph is achieved with the constructor graph(axiom, rules[, vars])  where axiom, rules and vars are the axiom, a tuple with  the graph rewriting rules and an user-defined object that stores all graph-level  variables, respectively. Note that the last argument is optional. The method  rewrite!(graph) takes a graph as input and executes the graph rewriting rules,  updating the internal state of the graph in-place. Note that this method will not be called implicitly: it is the responsability of the user to decide when to call this method.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The system is designed to allow rewriting of graphs in parallel, including shared memory approaches such as multi-threading with the Threads.@threads macro. This is ensure by deep-copying axiom, rules and vars so that changes in one  graph do not affect other graphs that may be built from the same axioms and rules. If user want some state to be shared across graphs, they should define a global  variable that is modified during execution of rules. If such approach is used, it is the responsibility of the user to ensure that updates to such global variables are properly locked or executed atomatically.","category":"page"},{"location":"manual/VPL.html#Graph-construction-algebra","page":"Dynamic graph creation and manipulation","title":"Graph-construction algebra","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"When initializing a graph and when specifying a graph rewriting rule it is  necessary to indicate the topological relationship between the nodes being  added to a graph (i.e. effectively we build graphs by appending sub-graphs). In  order to facilitate the description of these relationships, a simple algebra is  defined for all objects that inherit from Node.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The + operator indicates a linear parent-child dependency between the operands.  For example, M() + L() indicates that the object generated by L() is a child  of M(). A branching point is introduced by enclosing the children of a node  within () and separating the different branches with \",\". For example,  (M(1) + (L(2), L(3)) + M(4) + L(5)) creates a tree that starts with M(1),  has 3 children (L(2), L(3) and M(4)) and M(4) has a child L(5).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A graph always keep tracks of two special nodes: the root and the insertion point.  The root is the node that has no parent. When you use a graph rewriting rule (see  below) to replace a node a with a graph that has a root node b, the result is  that node a is replaced by node b and will inherit all the children and parent  from node a (plus the children that b already had in the replacement graph).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"An insertion point is the node of a graph where new nodes will be connected to  when using the + operator. Branches do not modify the insertion point of an  existing graph, but linear addition of nodes will always update the insertion  point to the last node. Thus, these two expressions produce the same tree  structure but with different insertion points: M(1) + (L(2), L(3)) + M(4) + L(5)  and M(1) + (L(2), L(3), M(4) + L(5)). In the first case, the insertion point  becomes the node L(5) but in the second case it remains at M(1). Keeping  track of the insertion point of a graph is important when building  a graph in  several steps.","category":"page"},{"location":"manual/VPL.html#Rules","page":"Dynamic graph creation and manipulation","title":"Rules","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Rules consist of directives that define the dynamic evolution of the nodes  that form a graph, by replacing a subset of the nodes by one or more nodes.  Rules are not executed directly by the user. Instead, they are stored in the  graph and executed by the method rewrite!. A rule is made of three parts:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The type of node to be replaced.\nA function to determine whether a candidate node is to be replaced ","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"or not (lhs function)","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A function that generates a node or subgraph to use as replacement ","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"(rhs function).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The first part must always be present, as it represents the minimum information  required to match the rule against nodes inside a graph. This type must be  the concrete type of the node rather an abstract type or union type from  which the node may inherit. The lhs and rhs functions are optional with the  following default values if missing:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"lhs: x -> true\nrhs: x -> nothing","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A rule with a missing lhs will match all the nodes of the specified type. A  rule without an rhs will remove any matched node and all of its children  (recursively, such that the topological tree is pruned).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A Context object includes the data stored inside a node plus its relationship  with other nodes in the graph, as well as a reference to the graph-level  variables. In order to extract the data stored in the node use the method  data. In order to extract the object containing all the graph-level variables,  use the method vars. The Context object may also be used to access other nodes  by walking through the graph (see below).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"For rules that do not capture the context of a node, the lhs part  is a function that takes an object of type Context and returns true or false,  whereas the rhs part is a function that takes a Context object and returns a  node or subgraph.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Although rules may also be used to update the internal state of a node (i.e.  by creating a new node of the same type but with a different state), this is only  required when the node is an immutable type. Otherwise, one can also (and  it is recommended to) use a query for better performance (see below).","category":"page"},{"location":"manual/VPL.html#Matching-relationships-among-nodes","page":"Dynamic graph creation and manipulation","title":"Matching relationships among nodes","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Sometimes the lhs function needs to check the relationships between nodes  inside a graph (e.g. match all leaves that belong to a particular branch of a  graph). In order achieve that, one can use the methods hasParent and hasChildren to  check for inmediate connections (i.e. effectively to check whether the node is a  root or a leaf in the graph) whereas hasAncestor and hasDescendant allow  traversing the graph and finding any connected node that matches a specific query.  If we need to extract the contents of the node, we may use the corresponding  functions parent, children, ancestor and descendant. Note that children  will return all the children nodes as a tuple, but the rest of functions only  return one node at a time. All these functions take a Context object as input  and return either true or false (for the functions that start with has) or a  Context or tuple of Context objects for the functions that extract the actual  connected node. These methods may also be used inside the rhs function of rules.  However, to avoid code repetition (and for performance reasons), it is recommended  to \"capture\" the Context objects of connected in the lhs function and pass  them to the rhs as described below.","category":"page"},{"location":"manual/VPL.html#Capturing-the-context-of-a-node","page":"Dynamic graph creation and manipulation","title":"Capturing the context of a node","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In some scenarios, knowing the relationship between nodes in the graph  is not sufficient, because data stored inside those related nodes is required  in the rhs function of a rule. In those cases, an extra argument to the constructor for a  Rule is required (captures = true) to indicate that this rule will pass  additional data from the lhs to the rhs function. Then, the lhs function should  return a tuple, where the first element is still true or false (to indicate  whether the rule matches a node) and the second ellement is a tuple of  Context objects associated to the nodes being matched. If not match occurs,  it is sufficient to return (false, ()), where () indicates an empty tuple.  The rhs function should then be a function that takes as first argument the  Context object of the node being replaced, and an additional argument for  every Context object being captured on the lhs function and passed to the rhs  function.","category":"page"},{"location":"manual/VPL.html#Execution-of-rules","page":"Dynamic graph creation and manipulation","title":"Execution of rules","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Rules are executed in the same order in which they are added to the graph object.  Then, the lhs part of each rule is tested against all nodes of the specified  type in the same order in which they were added to the graph. Similarly, the rhs  part of a rule will be applied to those nodes that matched the lhs part, in  the same order as in the matching.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The lhs part of all the rules are executed first and VPL will check that each  node is not matched by more than rule. In case there is more than one match,  an error will be generated. After all the lhs pars are executed, then the rhs parts  are executed on the matched nodes. Although generating an error may seem  restrictive, the  reasoning for this approach is as follows:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Graph rewriting is, conceptually, a parallel operation, so two rules cannot ","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"replace the same node, even if in the current version of VPL the rules  are applied sequentially (future versions may run rules on different threads).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"New nodes will be generated by graph rewriting rules that could be matched ","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"by the lhs of other graph rewriting rules. To guarantee that all rules rewrite  the same graph, all nodes that need to be replaced are identified before  any rhs part is executed. ","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In essence, you need to program your model such that it does not rely on any specific  order of execution of the graph rewriting rules. ","category":"page"},{"location":"manual/VPL.html#Query-and-apply","page":"Dynamic graph creation and manipulation","title":"Query and apply","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The apply method will apply a Query object to a graph and return a list of  nodes that match the query. The main differences between rules and queries is that queries  do not have an rhs part,they are not stored inside the graph and the user  decides when to apply them. Note that that a query does not modify a graph,  it simply returns a collection of nodes matched by it. Another difference is that  a query always return a reference to the data stored  inside the node, rather  than a Context object (so no need to use data). Note that if a query is used  to modify the data stored in a node, then the node needs to be a mutable type.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"For nodes of immutable type, a graph rewriting rule must be used to replace  the node. This may seem like a limitation but the fact is that, if one needs  to modify the state of an object after it has been created then, by definition,  that object should be of mutable type. If immutability is required for some reason,  one may keep track of associated variables at the graph level, but such kind of  manual book-keeping is not recommended.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A query is useful when the data stored inside the nodes of a graph need to  be modified or when these data are used as input for some function. Unlike in  rules, the order in which queries are applied in the code will affect the result of  the simulation, especially whether they are applied before or after a call to  rewrite!. The reasoning for this is that queries are not altering the structure  of a graph (since they do not remove nor create nodes) and multiple queries  can (and often do) match the same node. For example, one query will alter  an internal variable than is then need as input for another query. Thus, whereas  rules implicitly follow a parallel programming paradigm, queries follow a  sequential programming paradigm.","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Relational-queries","page":"Relational queries","title":"Relational queries","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"In this example we illustrate how to test relationships among nodes inside queries. Relational queries allow to establish relationships between nodes in the graph,  which generally requires a intimiate knowledge of the graph. For this reason, relational queries are inheretly complex as graphs can become complex and there may be solutions that do not require relational queries in many instances. Nevertheless, they are integral part of VPL and can sometimes be useful. As they can be hard to grasp, this tutorial will illustrate with a relatively simple graph a series of relational queries with increasing complexity with the aim that users will get a better understanding of relational queries. For this purpose,  an abstract graph with several branching levels will be used, so that we can focus on the relations among the nodes without being distracted by case-specific details.","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"The graph will be composed of two types of nodes: the inner nodes (A and C) and the  leaf nodes (B). Each leaf node will be identified uniquely with an index and the objective is to write queries that can identify a specific subset of the leaf nodes, without using the data stored in the nodes themselves. That is, the queries should select the right nodes based on their relationships to the rest of nodes in the graph. Note that C nodes contain a single value that may be positive or negative,  whereas A nodes contain no data.","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"As usual, we start with defining the types of nodes in the graph","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"using VPL\r\n\r\nstruct A <: Node end\r\n\r\nstruct C <: Node\r\n    val::Float64\r\nend\r\n\r\nstruct B <: Node\r\n    ID::Int\r\nend","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"We generate the graph directly, rather than with rewriting rules. The graph has a motif that is repeated three times (with a small variation), so we can create the graph in a piecewise manner. Note how we can use the function sum to add nodes to the graph (i.e. sum(A() for i in 1:3) is equivalent to A() + A() + A())","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"motif(n, i = 0) = A() + (C(45.0) + A() + (C(45.0) +  A() + B(i + 1), \r\n                                           C(-45.0) + A() + B(i + 2), \r\n                                                       A() + B(i + 3)), \r\n                         C(- 45.0) + sum(A() for i in 1:n) + B(i + 4))\r\naxiom =  motif(3, 0) + motif(2, 4) + motif(1, 8) + A() + A() + B(13)\r\ngraph = Graph(axiom);","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"If we draw this graph, by defauylt we can only see the types of graph and the internal node identification number automatically generated by VPL. However, we can define specific methods for the function get_id in order to customize how each type of node is represented in the graph. The function get_id takes as input the node identification number and the data stored in the node. Thus, we  can specialize on the type of the second argument. This function should always return a string, which is then drawn inside the boxes representing nodes in the graph.","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"VPL.get_id(node_id, data::A) = \"A\"\r\nVPL.get_id(node_id, data::C) = \"C\"*ifelse(sign(data.val) > 0.0, \"+\", \"-\")\r\nVPL.get_id(node_id, data::B) = \"B(\"*string(data.ID)*\")\"","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"And, as usual, the draw function will render the graph.","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"draw(graph)","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"The goal of the exercise is then to write queries that retrieve the following B nodes, without using the data stored in the node in the query:","category":"page"},{"location":"tutorials/advanced/relational_queries.html#All-nodes-of-type-B","page":"Relational queries","title":"All nodes of type B","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"First, we create the query object. In this case, there is no special condition as we want to retrieve all the nodes of type B","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q1 = Query(B)","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Applying the query to the graph returns an array with all the B nodes","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"A1 = apply(graph, Q1)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Node-containing-value-13","page":"Relational queries","title":"Node containing value 13","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Since the B node 13 is the leaf node of the main branch of the graph, there are no rotations between the root node of the graph and this node. Therefore, the only condition require to single out this node is that it has no ancestor node of type C. ","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Checking whether a node has an ancestor that meets a certain condition can be achieved with the function hasAncestor. Similarly to the  condition of the Query object, the hasAncestor function also has a condition, in this case applied to the parent node of the node being tested, and moving upwards in the graph recursively (until reaching the root node). Note that, in order to access the object stored inside the node, we need to use the data extractor, and then we can test if that object is of type C. The B node 13 is the only node for which hasAncestor should return false","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q2_fun(n)\r\n    check, steps = hasAncestor(n, x -> data(x) isa C)\r\n    !check\r\nend","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"As before, we just need to apply the Query object to the graph","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q2 = Query(B, Q2_fun)\r\nA2 = apply(graph, Q2)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Nodes-containing-values-1,-2-and-3","page":"Relational queries","title":"Nodes containing values 1, 2 and 3","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"These three nodes belong to one of the branch motifs repeated through the graph. Thus, we need to identify the specific motif they belong to and chose all the B nodes inside that motif. The motif is defined by an A node that has an C child with a negative val and parent node C with positive val. This A node  should then be 2 nodes away from the root node to separate it from upper repetitions of the motif. Therefore, we need to test for two conditions, first find those nodes inside a  branch motif, then retrieve the root of the branch motif (i.e. the A node  described in the above) and then check the distance of that node from the root.","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function branch_motif(p)\r\n    data(p) isa A && \r\n    hasDescendent(p, x -> data(x) isa C && data(x).val < 0.0) &&\r\n    hasAncestor(p, x -> data(x) isa C && data(x).val > 0.0)[1]\r\nend\r\n\r\nfunction Q3_fun(n, nsteps)\r\n    # Condition 1\r\n    check, steps = hasAncestor(n, branch_motif)\r\n    !check && return false\r\n    # Condition 2\r\n    p = parent(n, steps)\r\n    check, steps = hasAncestor(p, isRoot)\r\n    steps != nsteps && return false\r\n    return true\r\nend","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"And applying the query to the object results in the required nodes","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q3 = Query(B, n -> Q3_fun(n, 2))\r\nA3 = apply(graph, Q3)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Node-containing-value-4","page":"Relational queries","title":"Node containing value 4","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"The node B with value 4 can be singled-out because there is no branching point between the root node and the node. This means that no ancestor node should have more than one children node except the root node. Remember that hasAncestor returns two values, but we are only interested in the first value.","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q4_fun(n)\r\n    !hasAncestor(n, x -> !isRoot(x) && length(children(x)) > 1)[1]\r\nend","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"And applying the query to the object results in the required node","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q4 = Query(B, Q4_fun)\r\nA4 = apply(graph, Q4)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Node-containing-value-3","page":"Relational queries","title":"Node containing value 3","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"This node is the only B node four steps from the root node. ","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q5_fun(n)\r\n    check, steps = hasAncestor(n, isRoot)\r\n    steps == 4\r\nend\r\n\r\nQ5 = Query(B, Q5_fun)\r\nA5 = apply(graph, Q5)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Node-containing-value-7","page":"Relational queries","title":"Node containing value 7","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Node B 7 belongs to the second lateral branch motif and the second parent node is of type A. Note that we can reuse the Q3_fun for the first condition.","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q6_fun(n, nA)\r\n    check = Q3_fun(n, nA)\r\n    !check && return false\r\n    p2 = parent(n,2)\r\n    data(p2) isa A\r\nend\r\n\r\nQ6 = Query(B, n -> Q6_fun(n, 3))\r\nA6 = apply(graph, Q6)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Nodes-containing-values-11-and-13","page":"Relational queries","title":"Nodes containing values 11 and 13","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"The B nodes 11 and 13 actually have different relationships to the rest of the graph, so we just need to define two different condition functions and combined them. The condition for the B node 11 is similar to the B node 7, whereas the query for node 13 was already constructed, so we just need to reuse them","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q7 = Query(B, n -> Q6_fun(n, 4) || Q2_fun(n))\r\nA7 = apply(graph, Q7)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Nodes-containing-values-1,-5-and-9","page":"Relational queries","title":"Nodes containing values 1, 5 and 9","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"These nodes play the same role in the three lateral branch motifs. They are the only B nodes preceded by the sequence A - C+ - A. We just need to check the types of objects installed in the first three parents of each B node","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q8_fun(n)\r\n    p1 = parent(n)\r\n    p2 = parent(n, 2)\r\n    p3 = parent(n, 3)\r\n    data(p1) isa A && data(p2) isa C && data(p2).val > 0.0 && data(p3) isa A\r\nend\r\n\r\nQ8 = Query(B, Q8_fun)\r\nA8 = apply(graph, Q8)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Nodes-contaning-values-2,-6-and-10","page":"Relational queries","title":"Nodes contaning values 2, 6 and 10","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"This exercise is similar to the previous one, but the C node has a negative val. The problem is that node 12 would also match the query A - C- - A. We can differentiate with a fourth ancestor node of class C","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q9_fun(n)\r\n    p1 = parent(n)\r\n    p2 = parent(n, 2)\r\n    p3 = parent(n, 3)\r\n    p4 = parent(n, 4)\r\n    data(p1) isa A && data(p2) isa C && data(p2).val < 0.0 && \r\n       data(p3) isa A && data(p4) isa C\r\nend\r\n\r\nQ9 = Query(B, Q9_fun)\r\nA9 = apply(graph, Q9)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Nodes-containg-values-6,-7-and-8","page":"Relational queries","title":"Nodes containg values 6, 7 and 8","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"We already came up with a query to extract node 7. We can also modify the previous query to obtain a condition that selects only node 6. Node 8 requires a new  condition. These condition can be based on the third parent node being of type C  and being 5 nodes from the root of the graph.","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Rather than combining conditions as we did before","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q10_fun(n)\r\n    Q6_fun(n, 3) && return true # Check node 7\r\n    Q9_fun(n) && hasAncestor(n, isRoot)[2] == 6 && return true # Check node 6\r\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 3)) isa C && return true # Check node 8 (and not 4!)\r\nend\r\n\r\nQ10 = Query(B, Q10_fun)\r\nA10 = apply(graph, Q10)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Nodes-containig-values-3,-7,-11-and-12","page":"Relational queries","title":"Nodes containig values 3, 7, 11 and 12","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"We already have queries to select nodes 3,  7 and 11 and we need a new condition for node 12 (similar to the condition for 8).","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q11_fun(n)\r\n    Q5_fun(n) && return true # 3\r\n    Q6_fun(n, 3) && return true # 7\r\n    Q6_fun(n, 4) && return true # 11\r\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 2)) isa C && \r\n        data(parent(n, 4)) isa A && return true # 12\r\nend\r\n\r\nQ11 = Query(B, Q11_fun)\r\nA11 = apply(graph, Q11)","category":"page"},{"location":"tutorials/advanced/relational_queries.html#Nodes-containing-values-7-and-12","page":"Relational queries","title":"Nodes containing values 7 and 12","text":"","category":"section"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"We just need to combined the conditions for the nodes 7 and 12","category":"page"},{"location":"tutorials/advanced/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q12_fun(n)\r\n    Q6_fun(n, 3) && return true # 7\r\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 2)) isa C && \r\n        data(parent(n, 4)) isa A && return true # 12\r\nend\r\n\r\nQ12 = Query(B, Q12_fun)\r\nA12 = apply(graph, Q12)","category":"page"},{"location":"tutorials/introduction/01_algae.html#Algae-growth","page":"Algae growth","title":"Algae growth","text":"","category":"section"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"In this first example, we learn how to create a Graph and update it dynamically with rewriting rules. ","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"The model described here is based on the non-branching model of algae growth proposed by Lindermayer as one of the first L-systems.","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"First, we need to load the VPL metapackage, which will automatically load all the packages in the VPL ecosystem. ","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"using VPL","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"The rewriting rules of the L-system are as follows:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"axiom:   A  ","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"rule 1:  A rightarrow AB  ","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"rule 2:  B rightarrow A  ","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"In VPL, this L-system would be implemented as a graph where the nodes can be of type A and B and inherit from the abstract type Nodes:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"struct A <: Node end\r\nstruct B <: Node end","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"Note that in this very example we do not need to store any data or state inside the nodes, so types A and B do not require fields.","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"The axiom is simply defined as an instance of type of A:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"axiom = A()","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"The rewriting rules are implemented in VPL as objects of type Rule. In VPL, a rewriting rule substitutes a node in a graph with a new node or subgraph and is therefore composed of two parts:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"A condition that is tested against each node in a graph to choose which nodes to rewrite.  \nA subgraph that will replace each node selected by the condition above.  ","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"In VPL, the condition is split into two components:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"The type of node to be selected (in this example that would be A or B).  \nA function that is applied to each node in the graph (of the specified type) to indicate whether the node should be selected or not. This function is optional (the default is to select every node of the specified type).","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"The replacement subgraph is specified by a function that takes as input the node selected and returns a subgraph defined as a combination of node objects. Subgraphs (which can also be used as axioms) are created by linearly combining objects that inherit from Node. The operation + implies a linear relationship between two nodes and [] indicates branching.","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"The implementation of the two rules of algae growth model in VPL is as follows:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"rule1 = Rule(A, rhs = x -> A() + B())\r\nrule2 = Rule(B, rhs = x -> A())","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"Note that in each case, the argument rhs is being assigned an anonymous (aka lambda) function. This is a function without a name that is defined directly in the assigment to the argument. That is, the Julia expression x -> A() + B() is equivalent to the function definition:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"function rule_1(x)\r\n    A() + B()\r\nend","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"For simple rules (especially if the right hand side is just a line of code) it is easier to just define the right hand side of the rule with an anonymous function rather than defining a standalone function with a meaningful name. ","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"With the axiom and rules we can now create a Graph object that represents the algae organism. The first argument is the axiom and the second is a tuple with all the rewriting rules:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"algae = Graph(axiom, rules = (rule1, rule2))","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"We can visualize the graph by using the function draw. This will open an external window with an interactive network representation of the current state of the graph (as indicated above, I include below a screenshot of what you should get in your local device).","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"draw(algae);","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"You can see that at the moment the graph only contains the axiom, that is, a node of type A. If we apply the rewriting rules iteratively, the graph will grow, in this case representing the growth of the algae organism. The rewriting rules are applied on the graph with the function rewrite!:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"rewrite!(algae)","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"Since there was only one node of type A, the only rule that was applied was ruleA, so the graph should now have two nodes of types A and B, respectively. We can confirm this by drawing the graph.","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"draw(algae);","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"Notice that each node in the network representation is labelled with the type of node (A or B in this case) and a number in parenthesis. This number is a unique identifier associated to each node and it is useful for debugging purposes (this will be explained in more advanced examples).","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"Applying multiple iterations of rewriting can be achieved with a simple loop:","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"for i in 1:4\r\n    rewrite!(algae)\r\nend\r\ndraw(algae);","category":"page"},{"location":"tutorials/introduction/01_algae.html","page":"Algae growth","title":"Algae growth","text":"The network is rather boring as the system is growing linearly (no branching) but it already illustrates how graphs can grow rapidly in just a few iterations. Remember that the interactive visualization allows adjusting the zoom, which is handy when graphs become large.","category":"page"},{"location":"api/Core.html#Module-Core","page":"Core","title":"Module Core","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"CurrentModule = VPL.Core","category":"page"},{"location":"api/Core.html#Types","page":"Core","title":"Types","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Graph","category":"page"},{"location":"api/Core.html#VPL.Core.Graph","page":"Core","title":"VPL.Core.Graph","text":"Graph(axiom; rules = nothing, vars = nothing)\n\nCreates a dynamic graph defined by the initial node or nodes (axiom), one or more rules  (rules), and an object with graph-level variables (vars). Rules and graph-level variables are optional and must be assigned by keyword (see example below).  Rules must be an Rule or tuple of Rule objects.  The axiom may be a single object inheriting from Node or a subgraph generated  with the graph construction DSL.  A copy of the axiom and rules is always made when constructing the graph, but if object containing graph-level variables is not mutable, the user must manually copy (with copy or deepcopy) or else changes within the graph will affect the original object (and other graphs creates from the same object).\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nno_rules_graph = Graph(axiom)\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\n\n\n\n\n\n","category":"type"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Rule","category":"page"},{"location":"api/Core.html#VPL.Core.Rule","page":"Core","title":"VPL.Core.Rule","text":"Rule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\n\nCreate a replacement rule for nodes of type nodetype with function-like objects for the left-hand side (lhs) and right-hand side (rhs). If the rule captures nodes in the context of the replacement node this must be indicated by the argument captures.\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrewrite!(rules_graph)\n\n\n\n\n\n","category":"type"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Query","category":"page"},{"location":"api/Core.html#VPL.Core.Query","page":"Core","title":"VPL.Core.Query","text":"Query(nodetype::DataType, query = x -> true)\n\nCreate a query that matches nodes of type nodetype and the conditions specified in the argument query (must be a function that returns true). It returns an object of type Query that can be applied to a graph with the function apply.\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\n\n\n\n\n\n","category":"type"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Node","category":"page"},{"location":"api/Core.html#VPL.Core.Node","page":"Core","title":"VPL.Core.Node","text":"Node\n\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL\n\nExample\n\nstruct bar <: Node\n  x::Int\nend\nb1 = bar(1)\nb2 = bar(2)\nb1 + b2\n\n\n\n\n\n","category":"type"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Context","category":"page"},{"location":"api/Core.html#VPL.Core.Context","page":"Core","title":"VPL.Core.Context","text":"Context\n\nData structure than links a GraphNode to a Graph. Functions data and vars  give access to the data stored in the node and graph, respectively. Several  methods are also available to test relationships among nodes in the graph and to  extract these related nodes (see User Manual for details).\n\nUses do not build Context objects directly but they are provided by VPL as  inputs to the user-defined functions inside rules and queries. \n\n\n\n\n\n","category":"type"},{"location":"api/Core.html#Applying-rules-and-queries","page":"Core","title":"Applying rules and queries","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"apply(g::Graph, query::Query)","category":"page"},{"location":"api/Core.html#VPL.Core.apply-Tuple{VPL.Core.Graph, VPL.Core.Query}","page":"Core","title":"VPL.Core.apply","text":"apply(g::Graph, query::Query)\n\nReturn an array with all the nodes in the graph that match the query supplied by  the user.\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"rewrite!(g::Graph)","category":"page"},{"location":"api/Core.html#VPL.Core.rewrite!-Tuple{VPL.Core.Graph}","page":"Core","title":"VPL.Core.rewrite!","text":"rewrite!(g::Graph)\n\nApply the graph-rewriting rules stored in the graph. This function will match the left-hand sides of the rules against the graph and then replace and/or prune the graph at every location where the left-hand sides matched by the result of executing the right hand side of each rule. The modification is performed in-place, so this function returns nothing.\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrewrite!(rules_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html#Extracting-information","page":"Core","title":"Extracting information","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"vars(g::Graph)","category":"page"},{"location":"api/Core.html#VPL.Core.vars-Tuple{VPL.Core.Graph}","page":"Core","title":"VPL.Core.vars","text":"vars(g::Graph)\n\nReturns the object storing the graph-level variables\n\nExample\n\nstruct A <: Node end\naxiom = A()\ngraph = Graph(axiom, vars = 2)\nvars(graph)\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"rules(g::Graph)","category":"page"},{"location":"api/Core.html#VPL.Core.rules-Tuple{VPL.Core.Graph}","page":"Core","title":"VPL.Core.rules","text":"rules(g::Graph)\n\nReturns a tuple with all the graph-rewriting rules stored in the graph\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrules(rules_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"vars(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.vars-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.vars","text":"vars(c::Context)\n\nReturns the object storing the graph-level variables in the graph associated to  a Context object. This needs to be used inside rules and queries.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"data(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.data-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.data","text":"data(c::Context)\n\nReturns the data stored in the node associated to a Context object. This needs to be used inside rules and queries.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html#Graph-traversal","page":"Core","title":"Graph traversal","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"hasParent(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.hasParent-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.hasParent","text":"hasParent(c::Context)\n\nCheck if the node passed as argument has a parent and return true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"isRoot(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.isRoot-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.isRoot","text":"isRoot(c::Context)\n\nCheck if the node passed as argument is the root of the graph (i.e. has no parent)  and return true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"hasAncestor(c::Context, query, maxlevel::Int = typemax(Int))","category":"page"},{"location":"api/Core.html#VPL.Core.hasAncestor","page":"Core","title":"VPL.Core.hasAncestor","text":"hasAncestor(c::Context, condition, maxlevel)\n\nCheck if the node passed as argument has an ancestor that matches the optional  condition and and return true or false and the number of steps taken.  The argument maxlevel is optional and limits the number of steps that the  algorithm will move through the graph (by default there is no limitation). The default condition returns true for any ancestor  and it takes an object of type Context.\n\n\n\n\n\n","category":"function"},{"location":"api/Core.html","page":"Core","title":"Core","text":"parent(c::Context)","category":"page"},{"location":"api/Core.html#Base.parent-Tuple{VPL.Core.Context}","page":"Core","title":"Base.parent","text":"parent(c::Context, nsteps::Int)\n\nReturns a Context object associated to the parent of the node passed as first argument (nsteps = 1, the default) or an ancestor that is nsteps away from the node passed as first argument.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"ancestor(c::Context, query, maxlevel::Int = typemax(Int))","category":"page"},{"location":"api/Core.html#VPL.Core.ancestor","page":"Core","title":"VPL.Core.ancestor","text":"ancestor(c::Context, condition, maxlevel)\n\nReturns a Context object associated to the first ancestor of the node given as  argument that matches the optional condition. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a Context object. The default condition returns true for any ancestor and it takes an object of type Context.\n\n\n\n\n\n","category":"function"},{"location":"api/Core.html","page":"Core","title":"Core","text":"hasChildren(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.hasChildren-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.hasChildren","text":"hasChildren(c::Context)\n\nCheck if the node passed as argument has at least one child and return true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"isLeaf(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.isLeaf-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.isLeaf","text":"isLeaf(c::Context)\n\nCheck if the node passed as argument is a leaf in the graph (i.e. has no children)  and return true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"hasDescendent(c::Context, query, maxlevel::Int = typemax(Int))","category":"page"},{"location":"api/Core.html#VPL.Core.hasDescendent","page":"Core","title":"VPL.Core.hasDescendent","text":"hasDescendent(c::Context, condition, maxlevel)\n\nCheck if the node passed as argument has a descendent that matches the optional condition and and return true or false. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The default condition returns true for any descendent  and it takes an object of type Context.\n\n\n\n\n\n","category":"function"},{"location":"api/Core.html","page":"Core","title":"Core","text":"children(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.children-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.children","text":"children(c::Context)\n\nReturns a tuple of Context objects with all the children of thew node given as  argument.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"descendent(c::Context, query, maxlevel::Int = typemax(Int))","category":"page"},{"location":"api/Core.html#VPL.Core.descendent","page":"Core","title":"VPL.Core.descendent","text":"descendent(c::Context, condition, maxlevel)\n\nReturns a Context object associated to the first descendent of the node given as  argument that matches the optional condition. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a Context object. The default condition returns true for any descendent and it takes an object of type Context.\n\n\n\n\n\n","category":"function"},{"location":"api/Core.html","page":"Core","title":"Core","text":"traverse(g::Graph, f)","category":"page"},{"location":"api/Core.html#VPL.Core.traverse-Tuple{VPL.Core.Graph, Any}","page":"Core","title":"VPL.Core.traverse","text":"traverse(g::Graph, f)\n\nIterates over all the nodes in the graph (in no particular order) and execute for each node the function f taking as input the data stored in the node.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"traverseDFS(g::Graph, f)","category":"page"},{"location":"api/Core.html#VPL.Core.traverseDFS-Tuple{VPL.Core.Graph, Any}","page":"Core","title":"VPL.Core.traverseDFS","text":"traverseDFS(g::Graph, f)\n\nIterates over all the nodes in the graph (depth-first order, starting at the  root of the graph) and execute for each node the function f taking as input the  data stored in the node.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"traverseBFS(g::Graph, f)","category":"page"},{"location":"api/Core.html#VPL.Core.traverseBFS-Tuple{VPL.Core.Graph, Any}","page":"Core","title":"VPL.Core.traverseBFS","text":"traverseBFS(g::Graph, f)\n\nIterates over all the nodes in the graph (breadth-first order, starting at the  root of the graph) and execute for each node the function f taking as input the  data stored in the node.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html#Graph-visualization","page":"Core","title":"Graph visualization","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"draw(g::Graph; name::String = \"VPL Graph\")","category":"page"},{"location":"api/Core.html#VPL.Core.draw-Tuple{VPL.Core.Graph}","page":"Core","title":"VPL.Core.draw","text":"draw(g::Graph; name::String = \"VPL Graph\")\n\nDraw a network representation of the graph. The drawing is performed on a Blink window using the vis.js Javascript library. The function returns the handler to the Blink window. Access to Internet is required as the libraries are loaded from the cdns server.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"get_id(key, data)","category":"page"},{"location":"api/Core.html#VPL.Core.get_id-Tuple{Any, Any}","page":"Core","title":"VPL.Core.get_id","text":"get_id(key, data)\n\nMethod that defines the label associated to the node data when drawing the graph. The argument key is the unique identifier of the node in the graph. The default method prints the type of data stored in the node and the unique identifier of the node in parenthesis.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Virtual-Plant-Laboratory","page":"Introduction","title":"Virtual Plant Laboratory","text":"","category":"section"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The Virtual Plant Laboratory (VPL) is a Julia package that aids in the construction,  simulation and visualization of functional-structural plant models (FSPM). VPL  is not a standalone solution to all the computational problems relevant to FSPM,  but rather it focuses on those algorithms and visualizations that are specific to  FSPM and for which there are no good solutions in the Julia package ecosystem.  Furthermore, VPL is 100% written in Julia and therefore VPL will work in any  platform and with any code editor where Julia works. Finally, VPL does not offer  a domain specific language for FSPM but rather it allows building FSP models by  creating user-defined data types  and methods.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"There is no standard definition of what an  FSPM is, though these models will  always involve some combination of plant structure and function, so it is likely  that VPL will not be useful with every possible FSPM. Instead, VPL focuses on  models that represent indivudual plants as graphs of elements (usually organs)  that interact with each other and with the environment. In a typical VPL model,  each plant is represented by its own graph which can change dynamically through  the iterative application of graph rewriting rules. Based on this goal, what VPL  offers mainly are data structures and algorithms that allow ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"modelling dynamic graphs that represent plants,  \nmodelling the interaction between plants and their 3D environment by generating ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"3D structures from the graphs and simulating capture of different resources  (e.g. light) and ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"modelling the interaction among elements within each plant by constructing ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"dynamic networks that represent systems of ordinary differential equations. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"In terms of design, VPL gives priority to performance and simple interfaces as opposed to complex layers of abstraction. This implies that models in VPL may be more verbose and procedural (as opposed to descriptive) than in other FSPM platforms, while being more transparent and easier to follow.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"VPL requires using Julia version 1.6 or higher. The installation of VPL is as easy as running the following code:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(PackageSpec(url = \"https://git.wur.nl/vpl/vpl.git\", rev  = \"master\"))","category":"page"},{"location":"index.html#The-VPL-ecosystem","page":"Introduction","title":"The VPL ecosystem","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The package VPL contains all the basic functionality to build FSPM but, as  indicated earlier, the emphasis is on minimal, simple and transparent interfaces. In order to facilitate the construction of advanced FSPM, an ecosystem of  packages will be built around VPL that bring higher levels of abstraction and  reusable components with which models can be built.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The packages currently planned include","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Ecophys: Algorithms and data structures to simulate ecophysiological processes ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"including photosynthesis, transpiration, leaf energy balance, phenology,  respiration, nutrient and water uptake, etc.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Sky: Algorithms to simulate different sky conditions in terms of the intensity ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"of solar radiation and its spatial distribution.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"GCIM: A generic model that allows simulating multiple types of crops with an","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"emphasis on interactions among crops","category":"page"},{"location":"index.html#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for VPL is provided in this website in four formats:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"User manual\nTutorials and examples\nAPI\nTechnical notes","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"New users are expected to start with the tutorials and consult the user manual to understand better the different concepts used in VPL and get an overview of the different options available. The API documentation describes each individual  function and data type, with an emphasis on inputs and outputs and (in addition  to this website) it can be accessed from within Julia with ? (see the section  Accessing Documentation  in the Julia manual). The developer manual is useful for people who want to  understand the internal details of VPL and how different algorithms are  implemented (i.e. the developer manual should be seen as a supplementary to the source code of VPL).","category":"page"}]
}
