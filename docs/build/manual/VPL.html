<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dynamic graph creation and manipulation · VPL.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VPL.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">User Manual</span><ul><li class="is-active"><a class="tocitem" href="VPL.html">Dynamic graph creation and manipulation</a><ul class="internal"><li><a class="tocitem" href="#Graphs,-Rules-and-Queries"><span>Graphs, Rules and Queries</span></a></li><li class="toplevel"><a class="tocitem" href="#Graph"><span>Graph</span></a></li><li><a class="tocitem" href="#Graph-construction-algebra"><span>Graph-construction algebra</span></a></li><li class="toplevel"><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Matching-relationships-among-nodes"><span>Matching relationships among nodes</span></a></li><li><a class="tocitem" href="#Capturing-the-context-of-a-node"><span>Capturing the context of a node</span></a></li><li><a class="tocitem" href="#Execution-of-rules"><span>Execution of rules</span></a></li><li class="toplevel"><a class="tocitem" href="#Query-and-apply"><span>Query and <code>apply</code></span></a></li></ul></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/01_algae.html">Algae growth</a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/Core.html">Core</a></li></ul></li><li><span class="tocitem">Technical Notes</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Manual</a></li><li class="is-active"><a href="VPL.html">Dynamic graph creation and manipulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="VPL.html">Dynamic graph creation and manipulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AleMorales/VPL.jl/blob/master/docs/src/manual/VPL.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dynamic-graph-creation-and-manipulation"><a class="docs-heading-anchor" href="#Dynamic-graph-creation-and-manipulation">Dynamic graph creation and manipulation</a><a id="Dynamic-graph-creation-and-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-graph-creation-and-manipulation" title="Permalink"></a></h1><h2 id="Graphs,-Rules-and-Queries"><a class="docs-heading-anchor" href="#Graphs,-Rules-and-Queries">Graphs, Rules and Queries</a><a id="Graphs,-Rules-and-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs,-Rules-and-Queries" title="Permalink"></a></h2><p>A model in VPL is a (discrete) dynamical model that describes the time evolution  of one or more entities (i.e. objects of type <code>graph</code>). Each graph  (usually  assumed to be an individual plant) is characterized by a series of nodes  (usually organs) that are represented by nodes in a graph. Each node is  defined by its own state, including (if applicable) a description of its geometry,  color, optical propertes, etc. The dynamic simulation of a graph consists of the  creation and destruction of nodes via graph rewriting rules, and changes to  the internal state of its nodes with the help of queries.</p><p>The 3D structure of a graph is generated by processing its nodes using a  <strong>Turtle</strong> procedural geometry approach (i.e. inspired on Logo&#39;s turtle graphs  as used in L-systems) and following the topology of the graph. This 3D structure  may be used for visualization using a 3D renderer or for simulating  spatial  processes.</p><p>VPL does not provide a domain-specific language to implement rules and queries.  Rather, they are defined by functions which are stored in objects of types <code>Rule</code>  and <code>Query</code>, respectively. Similarly, the nodes of a graph can be of any  user-defined type, as long as the user defines the necessary methods to support  specific functionality (e.g. the <code>feedgeom!</code> method to generate geometry).</p><p>VPL is designed around data types and methods. Building a model in VPL typically requires:</p><ul><li>Defining types for the different classes of nodes of a graph</li><li>Creating rules and queries based on these types</li><li>Creating graphs by combining rules and the initial states of the graphs</li><li>Creating additional elements in the scene (e.g. soil)</li></ul><p>A simulation in VPL consists of executing rules iteratively and, within each iteration:</p><ul><li>Use queries to select subset of nodes and modify their states.</li><li>Modify graph-level variables directly.</li><li>Use algorithms in VPL to simulate interactions among nodes or between</li></ul><p>nodes and their environment.</p><p>In addition, VPL allows visualizing the results of a simulation by:</p><ul><li>3D rendering of the generated scenes</li><li>Network graph representing the nodes in the graph</li></ul><p>VPL is designed to facilitate modular model development, such as using different  types of graphs in the same simulation, alternative visualizations of the same  scene by mapping internal states of nodes to colors, or including multiple  ray tracers in the same simulation. Users may also create their own data types  that include graphs as fields or to nest graphs within other graphs.</p><h1 id="Graph"><a class="docs-heading-anchor" href="#Graph">Graph</a><a id="Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Graph" title="Permalink"></a></h1><p>A graph is the basic unit of a model in VPL. Three types of data are stored  inside a graph:</p><ul><li>Components of the graph.</li><li>Graph rewriting rules.</li><li>An user-defined object that characterizes the state of a graph besides its </li></ul><p>nodes (i.e. graph-level variables).</p><p>The nodes of a graph are objects created by the user that inherit from the  abstract type <code>Node</code>. This abstract type enables describing the relationship  between nodes using a simple algebra for graph construction (see below). A  graph always needs to be initialized by at least one node (i.e. analogous  to the axiom of L-Systems), as otherwise graph rewriting rules could not be  applied.</p><p>The creation of a graph is achieved with the constructor <code>graph(axiom, rules[, vars])</code>  where <code>axiom</code>, <code>rules</code> and <code>vars</code> are the axiom, a tuple with  the graph rewriting rules and an user-defined object that stores all graph-level  variables, respectively. Note that the last argument is optional. The method  <code>rewrite!(graph)</code> takes a graph as input and executes the graph rewriting rules,  updating the internal state of the graph in-place. Note that this method will not be called implicitly: it is the responsability of the user to decide when to call this method.</p><p>The system is designed to allow rewriting of graphs in parallel, including shared memory approaches such as multi-threading with the <code>Threads.@threads</code> macro. This is ensure by deep-copying <code>axiom</code>, <code>rules</code> and <code>vars</code> so that changes in one  graph do not affect other graphs that may be built from the same axioms and rules. If user want some state to be shared across graphs, they should define a global  variable that is modified during execution of rules. If such approach is used, it is the responsibility of the user to ensure that updates to such global variables are properly locked or executed atomatically.</p><h2 id="Graph-construction-algebra"><a class="docs-heading-anchor" href="#Graph-construction-algebra">Graph-construction algebra</a><a id="Graph-construction-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-construction-algebra" title="Permalink"></a></h2><p>When initializing a graph and when specifying a graph rewriting rule it is  necessary to indicate the topological relationship between the nodes being  added to a graph (i.e. effectively we build graphs by appending sub-graphs). In  order to facilitate the description of these relationships, a simple algebra is  defined for all objects that inherit from <code>Node</code>.</p><p>The <code>+</code> operator indicates a linear parent-child dependency between the operands.  For example, <code>M() + L()</code> indicates that the object generated by <code>L()</code> is a child  of <code>M()</code>. A branching point is introduced by enclosing the children of a node  within <code>()</code> and separating the different branches with &quot;,&quot;. For example,  <code>(M(1) + (L(2), L(3)) + M(4) + L(5))</code> creates a tree that starts with <code>M(1)</code>,  has 3 children (<code>L(2)</code>, <code>L(3)</code> and <code>M(4)</code>) and <code>M(4)</code> has a child <code>L(5)</code>.</p><p>A graph always keep tracks of two special nodes: the root and the insertion point.  The root is the node that has no parent. When you use a graph rewriting rule (see  below) to replace a node <em>a</em> with a graph that has a root node <em>b</em>, the result is  that node <em>a</em> is replaced by node <em>b</em> and will inherit all the children and parent  from node <em>a</em> (plus the children that <em>b</em> already had in the replacement graph).</p><p>An insertion point is the node of a graph where new nodes will be connected to  when using the <code>+</code> operator. Branches do not modify the insertion point of an  existing graph, but linear addition of nodes will always update the insertion  point to the last node. Thus, these two expressions produce the same tree  structure but with different insertion points: <code>M(1) + (L(2), L(3)) + M(4) + L(5)</code>  and <code>M(1) + (L(2), L(3), M(4) + L(5))</code>. In the first case, the insertion point  becomes the node <code>L(5)</code> but in the second case it remains at <code>M(1)</code>. Keeping  track of the insertion point of a graph is important when building  a graph in  several steps.</p><h1 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h1><p>Rules consist of directives that define the dynamic evolution of the nodes  that form a graph, by replacing a subset of the nodes by one or more nodes.  Rules are not executed directly by the user. Instead, they are stored in the  graph and executed by the method <code>rewrite!</code>. A rule is made of three parts:</p><ul><li>The type of node to be replaced.</li><li>A function to determine whether a candidate node is to be replaced </li></ul><p>or not (<strong>lhs</strong> function)</p><ul><li>A function that generates a node or subgraph to use as replacement </li></ul><p>(<strong>rhs</strong> function).</p><p>The first part must always be present, as it represents the minimum information  required to match the rule against nodes inside a graph. This type must be  the concrete type of the node rather an abstract type or union type from  which the node may inherit. The lhs and rhs functions are optional with the  following default values if missing:</p><ul><li>lhs: <code>x -&gt; true</code></li><li>rhs: <code>x -&gt; nothing</code></li></ul><p>A rule with a missing lhs will match all the nodes of the specified type. A  rule without an rhs will remove any matched node and all of its children  (recursively, such that the topological tree is pruned).</p><p>A <code>Context</code> object includes the data stored inside a node plus its relationship  with other nodes in the graph, as well as a reference to the graph-level  variables. In order to extract the data stored in the node use the method  <code>data</code>. In order to extract the object containing all the graph-level variables,  use the method <code>vars</code>. The <code>Context</code> object may also be used to access other nodes  by walking through the graph (see below).</p><p>For rules that do not capture the context of a node, the lhs part  is a function that takes an object of type <code>Context</code> and returns <code>true</code> or <code>false</code>,  whereas the rhs part is a function that takes a <code>Context</code> object and returns a  node or subgraph.</p><p>Although rules may also be used to update the internal state of a node (i.e.  by creating a new node of the same type but with a different state), this is only  required when the node is an immutable type. Otherwise, one can also (and  it is recommended to) use a query for better performance (see below).</p><h2 id="Matching-relationships-among-nodes"><a class="docs-heading-anchor" href="#Matching-relationships-among-nodes">Matching relationships among nodes</a><a id="Matching-relationships-among-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-relationships-among-nodes" title="Permalink"></a></h2><p>Sometimes the lhs function needs to check the relationships between nodes  inside a graph (e.g. match all leaves that belong to a particular branch of a  graph). In order achieve that, one can use the methods <code>hasParent</code> and <code>hasChildren</code> to  check for inmediate connections (i.e. effectively to check whether the node is a  root or a leaf in the graph) whereas <code>hasAncestor</code> and <code>hasDescendant</code> allow  traversing the graph and finding any connected node that matches a specific query.  If we need to extract the contents of the node, we may use the corresponding  functions <code>parent</code>, <code>children</code>, <code>ancestor</code> and <code>descendant</code>. Note that <code>children</code>  will return all the children nodes as a tuple, but the rest of functions only  return one node at a time. All these functions take a <code>Context</code> object as input  and return either <code>true</code> or <code>false</code> (for the functions that start with <em>has</em>) or a  <code>Context</code> or tuple of <code>Context</code> objects for the functions that extract the actual  connected node. These methods may also be used inside the rhs function of rules.  However, to avoid code repetition (and for performance reasons), it is recommended  to &quot;capture&quot; the <code>Context</code> objects of connected in the lhs function and pass  them to the rhs as described below.</p><h2 id="Capturing-the-context-of-a-node"><a class="docs-heading-anchor" href="#Capturing-the-context-of-a-node">Capturing the context of a node</a><a id="Capturing-the-context-of-a-node-1"></a><a class="docs-heading-anchor-permalink" href="#Capturing-the-context-of-a-node" title="Permalink"></a></h2><p>In some scenarios, knowing the relationship between nodes in the graph  is not sufficient, because data stored inside those related nodes is required  in the rhs function of a rule. In those cases, an extra argument to the constructor for a  <code>Rule</code> is required (<code>captures = true</code>) to indicate that this rule will pass  additional data from the lhs to the rhs function. Then, the lhs function should  return a tuple, where the first element is still <code>true</code> or <code>false</code> (to indicate  whether the rule matches a node) and the second ellement is a tuple of  <code>Context</code> objects associated to the nodes being matched. If not match occurs,  it is sufficient to return <code>(false, ())</code>, where <code>()</code> indicates an empty tuple.  The rhs function should then be a function that takes as first argument the  <code>Context</code> object of the node being replaced, and an additional argument for  every <code>Context</code> object being captured on the lhs function and passed to the rhs  function.</p><h2 id="Execution-of-rules"><a class="docs-heading-anchor" href="#Execution-of-rules">Execution of rules</a><a id="Execution-of-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Execution-of-rules" title="Permalink"></a></h2><p>Rules are executed in the same order in which they are added to the graph object.  Then, the lhs part of each rule is tested against all nodes of the specified  type in the same order in which they were added to the graph. Similarly, the rhs  part of a rule will be applied to those nodes that matched the lhs part, in  the same order as in the matching.</p><p>The lhs part of all the rules are executed first and VPL will check that each  node is not matched by more than rule. In case there is more than one match,  an error will be generated. After all the lhs pars are executed, then the rhs parts  are executed on the matched nodes. Although generating an error may seem  restrictive, the  reasoning for this approach is as follows:</p><ul><li>Graph rewriting is, conceptually, a parallel operation, so two rules cannot </li></ul><p>replace the same node, even if in the current version of VPL the rules  are applied sequentially (future versions may run rules on different threads).</p><ul><li>New nodes will be generated by graph rewriting rules that could be matched </li></ul><p>by the lhs of other graph rewriting rules. To guarantee that all rules rewrite  the same graph, all nodes that need to be replaced are identified before  any rhs part is executed. </p><p>In essence, you need to program your model such that it does not rely on any specific  order of execution of the graph rewriting rules. </p><h1 id="Query-and-apply"><a class="docs-heading-anchor" href="#Query-and-apply">Query and <code>apply</code></a><a id="Query-and-apply-1"></a><a class="docs-heading-anchor-permalink" href="#Query-and-apply" title="Permalink"></a></h1><p>The <code>apply</code> method will apply a <code>Query</code> object to a graph and return a list of  nodes that match the query. The main differences between rules and queries is that queries  do not have an rhs part,they are not stored inside the graph and the user  decides when to apply them. Note that that a query does not modify a graph,  it simply returns a collection of nodes matched by it. Another difference is that  a query always return a reference to the data stored  inside the node, rather  than a <code>Context</code> object (so no need to use <code>data</code>). Note that if a query is used  to modify the data stored in a node, then the node needs to be a mutable type.</p><p>For nodes of immutable type, a graph rewriting rule must be used to replace  the node. This may seem like a limitation but the fact is that, if one needs  to modify the state of an object after it has been created then, by definition,  that object should be of mutable type. If immutability is required for some reason,  one may keep track of associated variables at the graph level, but such kind of  manual book-keeping is not recommended.</p><p>A query is useful when the data stored inside the nodes of a graph need to  be modified or when these data are used as input for some function. Unlike in  rules, the order in which queries are applied in the code will affect the result of  the simulation, especially whether they are applied before or after a call to  <code>rewrite!</code>. The reasoning for this is that queries are not altering the structure  of a graph (since they do not remove nor create nodes) and multiple queries  can (and often do) match the same node. For example, one query will alter  an internal variable than is then need as input for another query. Thus, whereas  rules implicitly follow a parallel programming paradigm, queries follow a  sequential programming paradigm.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../index.html">« Introduction</a><a class="docs-footer-nextpage" href="../tutorials/introduction/01_algae.html">Algae growth »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 April 2021 12:42">Monday 12 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
