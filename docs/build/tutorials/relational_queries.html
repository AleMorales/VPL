<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Relational queries · VPL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">VPL.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">User Manual</span><ul><li><a class="tocitem" href="../manual/VPL.html">Dynamic graph creation and manipulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="algae.html">Algae growth</a></li><li class="is-active"><a class="tocitem" href="relational_queries.html">Relational queries</a><ul class="internal"><li><a class="tocitem" href="#All-nodes-of-type-B"><span>All nodes of type <code>B</code></span></a></li><li><a class="tocitem" href="#Node-containing-value-13"><span>Node containing value 13</span></a></li><li><a class="tocitem" href="#Nodes-containing-values-1,-2-and-3"><span>Nodes containing values 1, 2 and 3</span></a></li><li><a class="tocitem" href="#Node-containing-value-4"><span>Node containing value 4</span></a></li><li><a class="tocitem" href="#Node-containing-value-3"><span>Node containing value 3</span></a></li><li><a class="tocitem" href="#Node-containing-value-7"><span>Node containing value 7</span></a></li><li><a class="tocitem" href="#Nodes-containing-values-11-and-13"><span>Nodes containing values 11 and 13</span></a></li><li><a class="tocitem" href="#Nodes-containing-values-1,-5-and-9"><span>Nodes containing values 1, 5 and 9</span></a></li><li><a class="tocitem" href="#Nodes-contaning-values-2,-6-and-10"><span>Nodes contaning values 2, 6 and 10</span></a></li><li><a class="tocitem" href="#Nodes-containg-values-6,-7-and-8"><span>Nodes containg values 6, 7 and 8</span></a></li><li><a class="tocitem" href="#Nodes-containig-values-3,-7,-11-and-12"><span>Nodes containig values 3, 7, 11 and 12</span></a></li><li><a class="tocitem" href="#Nodes-containing-values-7-and-12"><span>Nodes containing values 7 and 12</span></a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/Core.html">Core</a></li></ul></li><li><span class="tocitem">Technical Notes</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="relational_queries.html">Relational queries</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="relational_queries.html">Relational queries</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AleMorales/VPL.jl/blob/master/docs/src/tutorials/relational_queries.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Relational-queries"><a class="docs-heading-anchor" href="#Relational-queries">Relational queries</a><a id="Relational-queries-1"></a><a class="docs-heading-anchor-permalink" href="#Relational-queries" title="Permalink"></a></h1><p>In this example we illustrate how to test relationships among nodes inside queries. Relational queries allow to establish relationships between nodes in the graph,  which generally requires a intimiate knowledge of the graph. For this reason, relational queries are inheretly complex as graphs can become complex and there may be solutions that do not require relational queries in many instances. Nevertheless, they are integral part of VPL and can sometimes be useful. As they can be hard to grasp, this tutorial will illustrate with a relatively simple graph a series of relational queries with increasing complexity with the aim that users will get a better understanding of relational queries. For this purpose,  an abstract graph with several branching levels will be used, so that we can focus on the relations among the nodes without being distracted by case-specific details.</p><p>The graph will be composed of two types of nodes: the inner nodes (<code>A</code> and <code>C</code>) and the  leaf nodes (<code>B</code>). Each leaf node will be identified uniquely with an index and the objective is to write queries that can identify a specific subset of the leaf nodes, without using the data stored in the nodes themselves. That is, the queries should select the right nodes based on their relationships to the rest of nodes in the graph. Note that <code>C</code> nodes contain a single value that may be positive or negative,  whereas <code>A</code> nodes contain no data.</p><p>&lt;!– TODO: Add some reminder related to struct re-definition...maybe we use modules from the beginning as good practice? –&gt;</p><p>As usual, we start with defining the types of nodes in the graph</p><pre><code class="language-julia hljs">using VPL

struct A &lt;: Node end

struct C &lt;: Node
    val::Float64
end

struct B &lt;: Node
    ID::Int
end</code></pre><p>We generate the graph directly, rather than with rewriting rules. The graph has a motif that is repeated three times (with a small variation), so we can create the graph in a piecewise manner. Note how we can use the function <code>sum</code> to add nodes to the graph (i.e. <code>sum(A() for i in 1:3)</code> is equivalent to <code>A() + A() + A()</code>)</p><pre><code class="language-julia hljs">motif(n, i = 0) = A() + (C(45.0) + A() + (C(45.0) +  A() + B(i + 1),
                                           C(-45.0) + A() + B(i + 2),
                                                       A() + B(i + 3)),
                         C(- 45.0) + sum(A() for i in 1:n) + B(i + 4))
axiom =  motif(3, 0) + motif(2, 4) + motif(1, 8) + A() + A() + B(13)
graph = Graph(axiom);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dynamic graph with 48 nodes of types Main.B,Main.A,Main.C and 0 rewriting rules.
</code></pre><p>&lt;!– TODO: Add comments to the graph being created in the relational_queries example –&gt;</p><p>If we draw this graph, by default we can only see the types of graph and the internal node identification number automatically generated by VPL. However, we can define a method for the function <code>get_id()</code> in order to customize how each type of node is represented in the graph. The function <code>get_id()</code> takes as input the node identification number and the data stored in the node. Thus, we  can specialize on the type of the second argument. This function should always return a string, which is then drawn inside the boxes representing nodes in the graph.</p><pre><code class="language-julia hljs">VPL.get_id(node_id, data::A) = &quot;A&quot;
VPL.get_id(node_id, data::C) = &quot;C&quot;*ifelse(sign(data.val) &gt; 0.0, &quot;+&quot;, &quot;-&quot;)
VPL.get_id(node_id, data::B) = &quot;B(&quot;*string(data.ID)*&quot;)&quot;</code></pre><p>And, as usual, the <code>draw()</code> function will render the graph but now it will use the methods defined in the above as labels per node.</p><pre><code class="language-julia hljs">draw(graph)</code></pre><p>The goal of this exercise is then to write queries that retrieve specific <code>B</code> nodes (without using the data stored in the node in the query, that is, we have to identify nodes based on their topological connections to other nodes).</p><h2 id="All-nodes-of-type-B"><a class="docs-heading-anchor" href="#All-nodes-of-type-B">All nodes of type <code>B</code></a><a id="All-nodes-of-type-B-1"></a><a class="docs-heading-anchor-permalink" href="#All-nodes-of-type-B" title="Permalink"></a></h2><p>First, we create the query object. In this case, there is no special condition as we want to retrieve all the nodes of type <code>B</code></p><pre><code class="language-julia hljs">Q1 = Query(B)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Query object for nodes of type Main.B
</code></pre><p>Applying the query to the graph returns an array with all the <code>B</code> nodes</p><pre><code class="language-julia hljs">A1 = apply(graph, Q1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13-element Vector{Main.B}:
 Main.B(7)
 Main.B(8)
 Main.B(3)
 Main.B(10)
 Main.B(5)
 Main.B(6)
 Main.B(2)
 Main.B(12)
 Main.B(1)
 Main.B(11)
 Main.B(13)
 Main.B(9)
 Main.B(4)</code></pre><h2 id="Node-containing-value-13"><a class="docs-heading-anchor" href="#Node-containing-value-13">Node containing value 13</a><a id="Node-containing-value-13-1"></a><a class="docs-heading-anchor-permalink" href="#Node-containing-value-13" title="Permalink"></a></h2><p>Since the <code>B</code> node 13 is the leaf node of the main branch of the graph (e.g. this could be the apical meristem of the main stem of a plant), there are no rotations between the root node of the graph and this node. Therefore, the only condition require to single out this node is that it has no ancestor node of type <code>C</code>. </p><p>Checking whether a node has an ancestor that meets a certain condition can be achieved with the function <code>hasAncestor()</code>. Similarly to the  condition of the <code>Query</code> object, the <code>hasAncestor()</code> function also has a condition, in this case applied to the parent node of the node being tested, and moving upwards in the graph recursively (until reaching the root node). Note that, in order to access the object stored inside the node, we need to use the <code>data()</code> function, and then we can test if that object is of type <code>C</code>. The <code>B</code> node 13 is the only node for which <code>hasAncestor()</code> should return <code>false</code>:</p><p>&lt;!– FIXME: Describe better what the hasAncestor function takes and returns –&gt;</p><pre><code class="language-julia hljs">function Q2_fun(n)
    check, steps = hasAncestor(n, x -&gt; data(x) isa C)
    !check
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Q2_fun (generic function with 1 method)</code></pre><p>As before, we just need to apply the <code>Query</code> object to the graph:</p><pre><code class="language-julia hljs">Q2 = Query(B, Q2_fun)
A2 = apply(graph, Q2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Main.B}:
 Main.B(13)</code></pre><h2 id="Nodes-containing-values-1,-2-and-3"><a class="docs-heading-anchor" href="#Nodes-containing-values-1,-2-and-3">Nodes containing values 1, 2 and 3</a><a id="Nodes-containing-values-1,-2-and-3-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-containing-values-1,-2-and-3" title="Permalink"></a></h2><p>These three nodes belong to one of the branch motifs repeated through the graph. Thus, we need to identify the specific motif they belong to and chose all the <code>B</code> nodes inside that motif. The motif is defined by an <code>A</code> node that has a <code>C</code> child with a negative <code>val</code> and parent node <code>C</code> with positive <code>val</code>. This <code>A</code> node  should then be 2 nodes away from the root node to separate it from upper repetitions of the motif. Therefore, we need to test for two conditions, first find those nodes inside a  branch motif, then retrieve the root of the branch motif (i.e., the <code>A</code> node  described in the above) and then check the distance of that node from the root:</p><pre><code class="language-julia hljs">function branch_motif(p)
    data(p) isa A &amp;&amp;
    hasDescendent(p, x -&gt; data(x) isa C &amp;&amp; data(x).val &lt; 0.0) &amp;&amp;
    hasAncestor(p, x -&gt; data(x) isa C &amp;&amp; data(x).val &gt; 0.0)[1]
end

function Q3_fun(n, nsteps)
    # Condition 1
    check, steps = hasAncestor(n, branch_motif)
    !check &amp;&amp; return false
    # Condition 2
    p = parent(n, steps)
    check, steps = hasAncestor(p, isRoot)
    steps != nsteps &amp;&amp; return false
    return true
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Q3_fun (generic function with 1 method)</code></pre><p>And applying the query to the object results in the required nodes:</p><pre><code class="language-julia hljs">Q3 = Query(B, n -&gt; Q3_fun(n, 2))
A3 = apply(graph, Q3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Main.B}:
 Main.B(3)
 Main.B(2)
 Main.B(1)</code></pre><h2 id="Node-containing-value-4"><a class="docs-heading-anchor" href="#Node-containing-value-4">Node containing value 4</a><a id="Node-containing-value-4-1"></a><a class="docs-heading-anchor-permalink" href="#Node-containing-value-4" title="Permalink"></a></h2><p>The node <code>B</code> with value 4 can be singled-out because there is no branching point between the root node and this node. This means that no ancestor node should have more than one children node except the root node. Remember that <code>hasAncestor()</code> returns two values, but we are only interested in the first value. You do not need to  assign the returned object from a Julia function, you can just index directly the element to be selected from the returned tuple:</p><pre><code class="language-julia hljs">function Q4_fun(n)
    !hasAncestor(n, x -&gt; !isRoot(x) &amp;&amp; length(children(x)) &gt; 1)[1]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Q4_fun (generic function with 1 method)</code></pre><p>And applying the query to the object results in the required node:</p><pre><code class="language-julia hljs">Q4 = Query(B, Q4_fun)
A4 = apply(graph, Q4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Main.B}:
 Main.B(4)</code></pre><h2 id="Node-containing-value-3"><a class="docs-heading-anchor" href="#Node-containing-value-3">Node containing value 3</a><a id="Node-containing-value-3-1"></a><a class="docs-heading-anchor-permalink" href="#Node-containing-value-3" title="Permalink"></a></h2><p>This node is the only <code>B</code> node that is four steps from the root node, which we can retrieve from the second argument returned by <code>hasAncestor()</code>:</p><pre><code class="language-julia hljs">function Q5_fun(n)
    check, steps = hasAncestor(n, isRoot)
    steps == 4
end

Q5 = Query(B, Q5_fun)
A5 = apply(graph, Q5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Main.B}:
 Main.B(3)</code></pre><h2 id="Node-containing-value-7"><a class="docs-heading-anchor" href="#Node-containing-value-7">Node containing value 7</a><a id="Node-containing-value-7-1"></a><a class="docs-heading-anchor-permalink" href="#Node-containing-value-7" title="Permalink"></a></h2><p>Node <code>B</code> 7 belongs to the second lateral branch motif and the second parent node is of type <code>A</code>. Note that we can reuse the <code>Q3_fun</code> from before in the  condition required for this node:</p><pre><code class="language-julia hljs">function Q6_fun(n, nA)
    check = Q3_fun(n, nA)
    !check &amp;&amp; return false
    p2 = parent(n,2)
    data(p2) isa A
end

Q6 = Query(B, n -&gt; Q6_fun(n, 3))
A6 = apply(graph, Q6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Main.B}:
 Main.B(7)</code></pre><h2 id="Nodes-containing-values-11-and-13"><a class="docs-heading-anchor" href="#Nodes-containing-values-11-and-13">Nodes containing values 11 and 13</a><a id="Nodes-containing-values-11-and-13-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-containing-values-11-and-13" title="Permalink"></a></h2><p>The <code>B</code> nodes 11 and 13 actually have different relationships to the rest of the graph, so we just need to define two different condition functions and combine them. The condition for the <code>B</code> node 11 is similar to the <code>B</code> node 7, whereas the condition for node 13 was already constructed before, so we just need to combined them with an OR operator:</p><pre><code class="language-julia hljs">Q7 = Query(B, n -&gt; Q6_fun(n, 4) || Q2_fun(n))
A7 = apply(graph, Q7)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Main.B}:
 Main.B(11)
 Main.B(13)</code></pre><h2 id="Nodes-containing-values-1,-5-and-9"><a class="docs-heading-anchor" href="#Nodes-containing-values-1,-5-and-9">Nodes containing values 1, 5 and 9</a><a id="Nodes-containing-values-1,-5-and-9-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-containing-values-1,-5-and-9" title="Permalink"></a></h2><p>These nodes play the same role in the three lateral branch motifs. They are the only <code>B</code> nodes preceded by the sequence A C+ A. We just need to check the sequence og types of objects for the the first three parents of each <code>B</code> node:</p><pre><code class="language-julia hljs">function Q8_fun(n)
    p1 = parent(n)
    p2 = parent(n, 2)
    p3 = parent(n, 3)
    data(p1) isa A &amp;&amp; data(p2) isa C &amp;&amp; data(p2).val &gt; 0.0 &amp;&amp; data(p3) isa A
end

Q8 = Query(B, Q8_fun)
A8 = apply(graph, Q8)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Main.B}:
 Main.B(5)
 Main.B(1)
 Main.B(9)</code></pre><h2 id="Nodes-contaning-values-2,-6-and-10"><a class="docs-heading-anchor" href="#Nodes-contaning-values-2,-6-and-10">Nodes contaning values 2, 6 and 10</a><a id="Nodes-contaning-values-2,-6-and-10-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-contaning-values-2,-6-and-10" title="Permalink"></a></h2><p>This exercise is similar to the previous one, but the C node has a negative <code>val</code>. The problem is that node 12 would also match the pattern A C- A. We can differentiate between this node and the rest by checking for a fourth  ancestor node of class <code>C</code>:</p><pre><code class="language-julia hljs">function Q9_fun(n)
    p1 = parent(n)
    p2 = parent(n, 2)
    p3 = parent(n, 3)
    p4 = parent(n, 4)
    data(p1) isa A &amp;&amp; data(p2) isa C &amp;&amp; data(p2).val &lt; 0.0 &amp;&amp;
       data(p3) isa A &amp;&amp; data(p4) isa C
end

Q9 = Query(B, Q9_fun)
A9 = apply(graph, Q9)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Main.B}:
 Main.B(10)
 Main.B(6)
 Main.B(2)</code></pre><h2 id="Nodes-containg-values-6,-7-and-8"><a class="docs-heading-anchor" href="#Nodes-containg-values-6,-7-and-8">Nodes containg values 6, 7 and 8</a><a id="Nodes-containg-values-6,-7-and-8-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-containg-values-6,-7-and-8" title="Permalink"></a></h2><p>We already came up with a condition to extract node 7. We can also modify the previous condition so that it only node 6.  Node 8 can be identified by checking for the third  parent node being of type <code>C</code> and being 5 nodes from the root of the graph.</p><p>As always, we can reusing previous conditions since they are just regular Julia functions:</p><pre><code class="language-julia hljs">function Q10_fun(n)
    Q6_fun(n, 3) &amp;&amp; return true # Check node 7
    Q9_fun(n) &amp;&amp; hasAncestor(n, isRoot)[2] == 6 &amp;&amp; return true # Check node 6
    hasAncestor(n, isRoot)[2] == 5 &amp;&amp; data(parent(n, 3)) isa C &amp;&amp; return true # Check node 8 (and not 4!)
end

Q10 = Query(B, Q10_fun)
A10 = apply(graph, Q10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Main.B}:
 Main.B(7)
 Main.B(8)
 Main.B(6)</code></pre><h2 id="Nodes-containig-values-3,-7,-11-and-12"><a class="docs-heading-anchor" href="#Nodes-containig-values-3,-7,-11-and-12">Nodes containig values 3, 7, 11 and 12</a><a id="Nodes-containig-values-3,-7,-11-and-12-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-containig-values-3,-7,-11-and-12" title="Permalink"></a></h2><p>We already have conditions to select nodes 3, 7 and 11 so we just need a new condition for node 12 (similar to the condition for 8).</p><pre><code class="language-julia hljs">function Q11_fun(n)
    Q5_fun(n) &amp;&amp; return true # 3
    Q6_fun(n, 3) &amp;&amp; return true # 7
    Q6_fun(n, 4) &amp;&amp; return true # 11
    hasAncestor(n, isRoot)[2] == 5 &amp;&amp; data(parent(n, 2)) isa C &amp;&amp;
        data(parent(n, 4)) isa A &amp;&amp; return true # 12
end

Q11 = Query(B, Q11_fun)
A11 = apply(graph, Q11)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Main.B}:
 Main.B(7)
 Main.B(3)
 Main.B(12)
 Main.B(11)</code></pre><h2 id="Nodes-containing-values-7-and-12"><a class="docs-heading-anchor" href="#Nodes-containing-values-7-and-12">Nodes containing values 7 and 12</a><a id="Nodes-containing-values-7-and-12-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-containing-values-7-and-12" title="Permalink"></a></h2><p>We just need to combine the conditions for the nodes 7 and 12</p><pre><code class="language-julia hljs">function Q12_fun(n)
    Q6_fun(n, 3) &amp;&amp; return true # 7
    hasAncestor(n, isRoot)[2] == 5 &amp;&amp; data(parent(n, 2)) isa C &amp;&amp;
        data(parent(n, 4)) isa A &amp;&amp; return true # 12
end

Q12 = Query(B, Q12_fun)
A12 = apply(graph, Q12)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Main.B}:
 Main.B(7)
 Main.B(12)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="algae.html">« Algae growth</a><a class="docs-footer-nextpage" href="../api/Core.html">Core »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 11 April 2022 15:23">Monday 11 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
