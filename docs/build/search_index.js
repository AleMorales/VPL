var documenterSearchIndex = {"docs":
[{"location":"tutorials/relational_queries.html#Relational-queries","page":"Relational queries","title":"Relational queries","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"In this example we illustrate how to test relationships among nodes inside queries. Relational queries allow to establish relationships between nodes in the graph,  which generally requires a intimiate knowledge of the graph. For this reason, relational queries are inheretly complex as graphs can become complex and there may be solutions that do not require relational queries in many instances. Nevertheless, they are integral part of VPL and can sometimes be useful. As they can be hard to grasp, this tutorial will illustrate with a relatively simple graph a series of relational queries with increasing complexity with the aim that users will get a better understanding of relational queries. For this purpose,  an abstract graph with several branching levels will be used, so that we can focus on the relations among the nodes without being distracted by case-specific details.","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"The graph will be composed of two types of nodes: the inner nodes (A and C) and the  leaf nodes (B). Each leaf node will be identified uniquely with an index and the objective is to write queries that can identify a specific subset of the leaf nodes, without using the data stored in the nodes themselves. That is, the queries should select the right nodes based on their relationships to the rest of nodes in the graph. Note that C nodes contain a single value that may be positive or negative,  whereas A nodes contain no data.","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"<!– TODO: Add some reminder related to struct re-definition...maybe we use modules from the beginning as good practice? –>","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"As usual, we start with defining the types of nodes in the graph","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"using VPL\r\n\r\nstruct A <: Node end\r\n\r\nstruct C <: Node\r\n    val::Float64\r\nend\r\n\r\nstruct B <: Node\r\n    ID::Int\r\nend","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"We generate the graph directly, rather than with rewriting rules. The graph has a motif that is repeated three times (with a small variation), so we can create the graph in a piecewise manner. Note how we can use the function sum to add nodes to the graph (i.e. sum(A() for i in 1:3) is equivalent to A() + A() + A())","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"motif(n, i = 0) = A() + (C(45.0) + A() + (C(45.0) +  A() + B(i + 1), \r\n                                           C(-45.0) + A() + B(i + 2), \r\n                                                       A() + B(i + 3)), \r\n                         C(- 45.0) + sum(A() for i in 1:n) + B(i + 4))\r\naxiom =  motif(3, 0) + motif(2, 4) + motif(1, 8) + A() + A() + B(13)\r\ngraph = Graph(axiom);","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"<!– TODO: Add comments to the graph being created in the relational_queries example –>","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"If we draw this graph, by default we can only see the types of graph and the internal node identification number automatically generated by VPL. However, we can define a method for the function get_id() in order to customize how each type of node is represented in the graph. The function get_id() takes as input the node identification number and the data stored in the node. Thus, we  can specialize on the type of the second argument. This function should always return a string, which is then drawn inside the boxes representing nodes in the graph.","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"VPL.get_id(node_id, data::A) = \"A\"\r\nVPL.get_id(node_id, data::C) = \"C\"*ifelse(sign(data.val) > 0.0, \"+\", \"-\")\r\nVPL.get_id(node_id, data::B) = \"B(\"*string(data.ID)*\")\"","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"And, as usual, the draw() function will render the graph but now it will use the methods defined in the above as labels per node.","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"draw(graph)","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"The goal of this exercise is then to write queries that retrieve specific B nodes (without using the data stored in the node in the query, that is, we have to identify nodes based on their topological connections to other nodes).","category":"page"},{"location":"tutorials/relational_queries.html#All-nodes-of-type-B","page":"Relational queries","title":"All nodes of type B","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"First, we create the query object. In this case, there is no special condition as we want to retrieve all the nodes of type B","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q1 = Query(B)","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Applying the query to the graph returns an array with all the B nodes","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"A1 = apply(graph, Q1)","category":"page"},{"location":"tutorials/relational_queries.html#Node-containing-value-13","page":"Relational queries","title":"Node containing value 13","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Since the B node 13 is the leaf node of the main branch of the graph (e.g. this could be the apical meristem of the main stem of a plant), there are no rotations between the root node of the graph and this node. Therefore, the only condition require to single out this node is that it has no ancestor node of type C. ","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Checking whether a node has an ancestor that meets a certain condition can be achieved with the function hasAncestor(). Similarly to the  condition of the Query object, the hasAncestor() function also has a condition, in this case applied to the parent node of the node being tested, and moving upwards in the graph recursively (until reaching the root node). Note that, in order to access the object stored inside the node, we need to use the data() function, and then we can test if that object is of type C. The B node 13 is the only node for which hasAncestor() should return false:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"<!– FIXME: Describe better what the hasAncestor function takes and returns –>","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q2_fun(n)\r\n    check, steps = hasAncestor(n, x -> data(x) isa C)\r\n    !check\r\nend","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"As before, we just need to apply the Query object to the graph:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q2 = Query(B, Q2_fun)\r\nA2 = apply(graph, Q2)","category":"page"},{"location":"tutorials/relational_queries.html#Nodes-containing-values-1,-2-and-3","page":"Relational queries","title":"Nodes containing values 1, 2 and 3","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"These three nodes belong to one of the branch motifs repeated through the graph. Thus, we need to identify the specific motif they belong to and chose all the B nodes inside that motif. The motif is defined by an A node that has a C child with a negative val and parent node C with positive val. This A node  should then be 2 nodes away from the root node to separate it from upper repetitions of the motif. Therefore, we need to test for two conditions, first find those nodes inside a  branch motif, then retrieve the root of the branch motif (i.e., the A node  described in the above) and then check the distance of that node from the root:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function branch_motif(p)\r\n    data(p) isa A && \r\n    hasDescendent(p, x -> data(x) isa C && data(x).val < 0.0) &&\r\n    hasAncestor(p, x -> data(x) isa C && data(x).val > 0.0)[1]\r\nend\r\n\r\nfunction Q3_fun(n, nsteps)\r\n    # Condition 1\r\n    check, steps = hasAncestor(n, branch_motif)\r\n    !check && return false\r\n    # Condition 2\r\n    p = parent(n, steps)\r\n    check, steps = hasAncestor(p, isRoot)\r\n    steps != nsteps && return false\r\n    return true\r\nend","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"And applying the query to the object results in the required nodes:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q3 = Query(B, n -> Q3_fun(n, 2))\r\nA3 = apply(graph, Q3)","category":"page"},{"location":"tutorials/relational_queries.html#Node-containing-value-4","page":"Relational queries","title":"Node containing value 4","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"The node B with value 4 can be singled-out because there is no branching point between the root node and this node. This means that no ancestor node should have more than one children node except the root node. Remember that hasAncestor() returns two values, but we are only interested in the first value. You do not need to  assign the returned object from a Julia function, you can just index directly the element to be selected from the returned tuple:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q4_fun(n)\r\n    !hasAncestor(n, x -> !isRoot(x) && length(children(x)) > 1)[1]\r\nend","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"And applying the query to the object results in the required node:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q4 = Query(B, Q4_fun)\r\nA4 = apply(graph, Q4)","category":"page"},{"location":"tutorials/relational_queries.html#Node-containing-value-3","page":"Relational queries","title":"Node containing value 3","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"This node is the only B node that is four steps from the root node, which we can retrieve from the second argument returned by hasAncestor():","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q5_fun(n)\r\n    check, steps = hasAncestor(n, isRoot)\r\n    steps == 4\r\nend\r\n\r\nQ5 = Query(B, Q5_fun)\r\nA5 = apply(graph, Q5)","category":"page"},{"location":"tutorials/relational_queries.html#Node-containing-value-7","page":"Relational queries","title":"Node containing value 7","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Node B 7 belongs to the second lateral branch motif and the second parent node is of type A. Note that we can reuse the Q3_fun from before in the  condition required for this node:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q6_fun(n, nA)\r\n    check = Q3_fun(n, nA)\r\n    !check && return false\r\n    p2 = parent(n,2)\r\n    data(p2) isa A\r\nend\r\n\r\nQ6 = Query(B, n -> Q6_fun(n, 3))\r\nA6 = apply(graph, Q6)","category":"page"},{"location":"tutorials/relational_queries.html#Nodes-containing-values-11-and-13","page":"Relational queries","title":"Nodes containing values 11 and 13","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"The B nodes 11 and 13 actually have different relationships to the rest of the graph, so we just need to define two different condition functions and combine them. The condition for the B node 11 is similar to the B node 7, whereas the condition for node 13 was already constructed before, so we just need to combined them with an OR operator:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"Q7 = Query(B, n -> Q6_fun(n, 4) || Q2_fun(n))\r\nA7 = apply(graph, Q7)","category":"page"},{"location":"tutorials/relational_queries.html#Nodes-containing-values-1,-5-and-9","page":"Relational queries","title":"Nodes containing values 1, 5 and 9","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"These nodes play the same role in the three lateral branch motifs. They are the only B nodes preceded by the sequence A C+ A. We just need to check the sequence og types of objects for the the first three parents of each B node:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q8_fun(n)\r\n    p1 = parent(n)\r\n    p2 = parent(n, 2)\r\n    p3 = parent(n, 3)\r\n    data(p1) isa A && data(p2) isa C && data(p2).val > 0.0 && data(p3) isa A\r\nend\r\n\r\nQ8 = Query(B, Q8_fun)\r\nA8 = apply(graph, Q8)","category":"page"},{"location":"tutorials/relational_queries.html#Nodes-contaning-values-2,-6-and-10","page":"Relational queries","title":"Nodes contaning values 2, 6 and 10","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"This exercise is similar to the previous one, but the C node has a negative val. The problem is that node 12 would also match the pattern A C- A. We can differentiate between this node and the rest by checking for a fourth  ancestor node of class C:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q9_fun(n)\r\n    p1 = parent(n)\r\n    p2 = parent(n, 2)\r\n    p3 = parent(n, 3)\r\n    p4 = parent(n, 4)\r\n    data(p1) isa A && data(p2) isa C && data(p2).val < 0.0 && \r\n       data(p3) isa A && data(p4) isa C\r\nend\r\n\r\nQ9 = Query(B, Q9_fun)\r\nA9 = apply(graph, Q9)","category":"page"},{"location":"tutorials/relational_queries.html#Nodes-containg-values-6,-7-and-8","page":"Relational queries","title":"Nodes containg values 6, 7 and 8","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"We already came up with a condition to extract node 7. We can also modify the previous condition so that it only node 6.  Node 8 can be identified by checking for the third  parent node being of type C and being 5 nodes from the root of the graph.","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"As always, we can reusing previous conditions since they are just regular Julia functions:","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q10_fun(n)\r\n    Q6_fun(n, 3) && return true # Check node 7\r\n    Q9_fun(n) && hasAncestor(n, isRoot)[2] == 6 && return true # Check node 6\r\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 3)) isa C && return true # Check node 8 (and not 4!)\r\nend\r\n\r\nQ10 = Query(B, Q10_fun)\r\nA10 = apply(graph, Q10)","category":"page"},{"location":"tutorials/relational_queries.html#Nodes-containig-values-3,-7,-11-and-12","page":"Relational queries","title":"Nodes containig values 3, 7, 11 and 12","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"We already have conditions to select nodes 3, 7 and 11 so we just need a new condition for node 12 (similar to the condition for 8).","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q11_fun(n)\r\n    Q5_fun(n) && return true # 3\r\n    Q6_fun(n, 3) && return true # 7\r\n    Q6_fun(n, 4) && return true # 11\r\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 2)) isa C && \r\n        data(parent(n, 4)) isa A && return true # 12\r\nend\r\n\r\nQ11 = Query(B, Q11_fun)\r\nA11 = apply(graph, Q11)","category":"page"},{"location":"tutorials/relational_queries.html#Nodes-containing-values-7-and-12","page":"Relational queries","title":"Nodes containing values 7 and 12","text":"","category":"section"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"We just need to combine the conditions for the nodes 7 and 12","category":"page"},{"location":"tutorials/relational_queries.html","page":"Relational queries","title":"Relational queries","text":"function Q12_fun(n)\r\n    Q6_fun(n, 3) && return true # 7\r\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 2)) isa C && \r\n        data(parent(n, 4)) isa A && return true # 12\r\nend\r\n\r\nQ12 = Query(B, Q12_fun)\r\nA12 = apply(graph, Q12)","category":"page"},{"location":"manual/VPL.html#Dynamic-graph-creation-and-manipulation","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"","category":"section"},{"location":"manual/VPL.html#Graphs,-Rules-and-Queries","page":"Dynamic graph creation and manipulation","title":"Graphs, Rules and Queries","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A model in VPL is a (discrete) dynamical model that describes the time evolution  of one or more entities (i.e. objects of type graph). Each graph  (usually  assumed to be an individual plant) is characterized by a series of nodes  (usually organs) that are represented by nodes in a graph. Each node is  defined by its own state, including (if applicable) a description of its geometry,  color, optical propertes, etc. The dynamic simulation of a graph consists of the  creation and destruction of nodes via graph rewriting rules, and changes to  the internal state of its nodes with the help of queries.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The 3D structure of a graph is generated by processing its nodes using a  Turtle procedural geometry approach (i.e. inspired on Logo's turtle graphs  as used in L-systems) and following the topology of the graph. This 3D structure  may be used for visualization using a 3D renderer or for simulating  spatial  processes.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL does not provide a domain-specific language to implement rules and queries.  Rather, they are defined by functions which are stored in objects of types Rule  and Query, respectively. Similarly, the nodes of a graph can be of any  user-defined type, as long as the user defines the necessary methods to support  specific functionality (e.g. the feedgeom! method to generate geometry).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL is designed around data types and methods. Building a model in VPL typically requires:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Defining types for the different classes of nodes of a graph\nCreating rules and queries based on these types\nCreating graphs by combining rules and the initial states of the graphs\nCreating additional elements in the scene (e.g. soil)","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A simulation in VPL consists of executing rules iteratively and, within each iteration:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Use queries to select subset of nodes and modify their states.\nModify graph-level variables directly.\nUse algorithms in VPL to simulate interactions among nodes or between nodes and their environment.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In addition, VPL allows visualizing the results of a simulation by:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"3D rendering of the generated scenes\nNetwork graph representing the nodes in the graph","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL is designed to facilitate modular model development, such as using different  types of graphs in the same simulation, alternative visualizations of the same  scene by mapping internal states of nodes to colors, or including multiple  ray tracers in the same simulation. Users may also create their own data types  that include graphs as fields or to nest graphs within other graphs.","category":"page"},{"location":"manual/VPL.html#Graph","page":"Dynamic graph creation and manipulation","title":"Graph","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A graph is the basic unit of a model in VPL. Three types of data are stored  inside a graph:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Components of the graph.\nGraph rewriting rules.\nAn user-defined object that characterizes the state of a graph besides its nodes (i.e. graph-level variables).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The nodes of a graph are objects created by the user that inherit from the  abstract type Node. This abstract type enables describing the relationship  between nodes using a simple algebra for graph construction (see below). A  graph always needs to be initialized by at least one node (i.e. analogous  to the axiom of L-Systems), as otherwise graph rewriting rules could not be  applied.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The creation of a graph is achieved with the constructor graph(axiom, rules[, vars])  where axiom, rules and vars are the axiom, a tuple with  the graph rewriting rules and an user-defined object that stores all graph-level  variables, respectively. Note that the last argument is optional. The method  rewrite!(graph) takes a graph as input and executes the graph rewriting rules,  updating the internal state of the graph in-place. Note that this method will not be called implicitly: it is the responsability of the user to decide when to call this method.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The system is designed to allow rewriting of graphs in parallel, including shared memory approaches such as multi-threading with the Threads.@threads macro. This is ensured by deep-copying axiom, rules and vars so that changes in one  graph do not affect other graphs that may be built from the same axioms and rules. If the user wants some state to be shared across graphs, they should define a global  variable that is modified during execution of rules. If such approach is used, it is the responsibility of the user to ensure that updates to such global variables are properly locked or executed atomatically.","category":"page"},{"location":"manual/VPL.html#Graph-construction-algebra","page":"Dynamic graph creation and manipulation","title":"Graph-construction algebra","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"When initializing a graph and when specifying a graph rewriting rule it is  necessary to indicate the topological relationship between the nodes being  added to a graph (i.e. effectively we build graphs by appending sub-graphs). In  order to facilitate the description of these relationships, a simple algebra is  defined for all objects that inherit from Node.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The + operator indicates a linear parent-child dependency between the operands.  For example, M() + L() indicates that the object generated by L() is a child  of M(). A branching point is introduced by enclosing the children of a node  within () and separating the different branches with \",\". For example,  (M(1) + (L(2), L(3)) + M(4) + L(5)) creates a tree that starts with M(1),  has 3 children (L(2), L(3) and M(4)) and M(4) has a child L(5).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A graph always keep tracks of two special nodes: the root and the insertion point.  The root is the node that has no parent. When you use a graph rewriting rule (see  below) to replace a node a with a graph that has a root node b, the result is  that node a is replaced by node b and will inherit all the children and parent  from node a (plus the children that b already had in the replacement graph).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"An insertion point is the node of a graph where new nodes will be connected to  when using the + operator. Branches do not modify the insertion point of an  existing graph, but linear addition of nodes will always update the insertion  point to the last node. Thus, these two expressions produce the same tree  structure but with different insertion points: M(1) + (L(2), L(3)) + M(4) + L(5)  and M(1) + (L(2), L(3), M(4) + L(5)). In the first case, the insertion point  becomes the node L(5) but in the second case it remains at M(1). Keeping  track of the insertion point of a graph is important when building  a graph in  several steps.","category":"page"},{"location":"manual/VPL.html#Rules","page":"Dynamic graph creation and manipulation","title":"Rules","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Rules consist of directives that define the dynamic evolution of the nodes  that form a graph, by replacing a subset of the nodes by one or more nodes.  Rules are not executed directly by the user. Instead, they are stored in the  graph and executed by the method rewrite!. A rule is made of three parts:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The type of node to be replaced.\nA function to determine whether a candidate node is to be replaced  or not (lhs function)\nA function that generates a node or subgraph to use as replacement (rhs function).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The first part must always be present, as it represents the minimum information  required to match the rule against nodes inside a graph. This type must be  the concrete type of the node rather an abstract type or union type from  which the node may inherit. The lhs and rhs functions are optional with the  following default values if missing:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"lhs: x -> true\nrhs: x -> nothing","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A rule with a missing lhs will match all the nodes of the specified type. A  rule without an rhs will remove any matched node and all of its children  (recursively, such that the topological tree is pruned).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A Context object includes the data stored inside a node plus its relationship  with other nodes in the graph, as well as a reference to the graph-level  variables. In order to extract the data stored in the node use the function  data(). In order to extract the object containing all the graph-level variables,  use the method vars. The Context object may also be used to access other nodes  by walking through the graph (see below).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"For rules that do not capture the context of a node, the lhs part  is a function that takes an object of type Context and returns true or false,  whereas the rhs part is a function that takes a Context object and returns a  node or subgraph.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Although rules may also be used to update the internal state of a node (i.e.  by creating a new node of the same type but with a different state), this is only  required when the node is an immutable type. Otherwise, one can also (and  it is recommended to) use a query for better performance (see below).","category":"page"},{"location":"manual/VPL.html#Matching-relationships-among-nodes","page":"Dynamic graph creation and manipulation","title":"Matching relationships among nodes","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Sometimes the lhs function needs to check the relationships between nodes  inside a graph (e.g. match all leaves that belong to a particular branch of a  graph). In order achieve that, one can use the functions hasParent() and hasChildren() to  check for inmediate connections (i.e. effectively to check whether the node is a  root or a leaf in the graph) whereas hasAncestor() and hasDescendant() allow  traversing the graph and finding any connected node that matches a specific query.  If we need to extract the contents of the node, we may use the corresponding  functions parent(), children(), ancestor() and descendant(). Note that children()  will return all the children nodes as a tuple, but the rest of functions only  return one node at a time. All these functions take a Context object as input  and return either true or false (for the functions that start with has) or a  Context or tuple of Context objects for the functions that extract the actual  connected node. These methods may also be used inside the rhs function of rules.  However, to avoid code repetition (and for performance reasons), it is recommended  to capture the Context objects of connected in the lhs function and pass  them to the rhs as described below (see below).","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"<!– TODO: Add a table with the inputs and outputs of each graph-related method –>","category":"page"},{"location":"manual/VPL.html#Capturing-the-context-of-a-node","page":"Dynamic graph creation and manipulation","title":"Capturing the context of a node","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In some scenarios, knowing the relationship between nodes in the graph  is not sufficient, because data stored inside those related nodes is required  in the rhs function of a rule. In those cases, an extra argument to the constructor for a  Rule is required (captures = true) to indicate that this rule will pass  additional data from the lhs to the rhs function. Then, the lhs function should  return a tuple, where the first element is still true or false (to indicate  whether the rule matches a node) and the second element is a tuple of  Context objects associated to the nodes being matched. If no match occurs,  it is sufficient to return (false, ()), where () indicates an empty tuple.  The rhs function should then be a function that takes as first argument the  Context object of the node being replaced, and an additional argument for  every Context object being captured on the lhs function and passed to the rhs  function.","category":"page"},{"location":"manual/VPL.html#Execution-of-rules","page":"Dynamic graph creation and manipulation","title":"Execution of rules","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Rules are executed in the same order in which they are added to the graph object.  Then, the lhs part of each rule is tested against all nodes of the specified  type in the same order in which they were added to the graph. Similarly, the rhs  part of a rule will be applied to those nodes that matched the lhs part, in  the same order as in the matching.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"<!– TODO: Diagram on rule execution –>","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The lhs part of all the rules are executed first and VPL will check that each  node is not matched by more than rule. In case there is more than one match,  an error will be generated. After all the lhs pars are executed, then the rhs parts  are executed on the matched nodes. Although generating an error may seem  restrictive, the  reasoning for this approach is as follows:","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Graph rewriting is, conceptually, a parallel operation, so two rules cannot replace the same node as that would mean the result depends on the order in which the rules are executed.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"New nodes will be generated by graph rewriting rules that could be matched by the lhs of other graph rewriting rules. To guarantee that all rules rewrite the same graph, all nodes that need to be replaced are identified before any rhs function is executed. ","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In essence, you need to program your model such that it does not rely on any specific order of execution of the graph rewriting rules.","category":"page"},{"location":"manual/VPL.html#Query-and-apply","page":"Dynamic graph creation and manipulation","title":"Query and apply","text":"","category":"section"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The apply() function will apply a Query object to a graph and return a list of  nodes that match the query. The main differences between rules and queries is that queries  do not have an rhs part,they are not stored inside the graph and the user  decides when to apply them. Note that that a query does not modify a graph,  it simply returns a collection of nodes matched by it. Another difference is that  a query always return a reference to the data stored  inside the node, rather  than a Context object (so no need to use data()). Note that if a query is used  to modify the data stored in a node, then the node needs to be a mutable type.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"For nodes of immutable type, a graph rewriting rule must be used to replace  the node. This may seem like a limitation but the fact is that, if one needs  to modify the state of an object after it has been created then, by definition,  that object should be of mutable type. If immutability is required for some reason,  one may keep track of associated variables at the graph level, but such kind of  manual book-keeping is not recommended.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A query is useful when the data stored inside the nodes of a graph need to  be modified or when these data are used as input for some function. Unlike in  rules, the order in which queries are applied in the code will affect the result of  the simulation, especially whether they are applied before or after a call to  rewrite!. The reasoning for this is that queries are not altering the structure  of a graph (since they do not remove nor create nodes) and multiple queries  can (and often do) match the same node. For example, one query will alter  an internal variable that is then need as input by another query. Thus, whereas  rules implicitly follow a parallel programming paradigm, queries follow a  sequential programming paradigm.","category":"page"},{"location":"manual/VPL.html","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"<!– TODO: Diagram that clarifies differences between rules and queries –>","category":"page"},{"location":"tutorials/algae.html#Algae-growth","page":"Algae growth","title":"Algae growth","text":"","category":"section"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"In this first example, we learn how to create a Graph and update it dynamically with rewriting rules.","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"The model described here is based on the non-branching model of algae growth proposed by Lindermayer as one of the first L-systems.","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"First, we need to load the VPL metapackage, which will automatically load all the packages in the VPL ecosystem.","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"using VPL","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"The rewriting rules of the L-system are as follows:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"axiom: A","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"rule 1: A → AB","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"rule 2: B → A","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"In VPL, this L-system would be implemented as a graph where the nodes can be of type A or B and inherit from the abstract type Node:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"struct A <: Node end\r\nstruct B <: Node end","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"Note that in this very example we do not need to store any data or state inside the nodes, so types A and B do not require fields.","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"The axiom is simply defined as an instance of type of A:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"axiom = A()","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"The rewriting rules are implemented in VPL as objects of type Rule. In VPL, a rewriting rule substitutes a node in a graph with a new node or subgraph and is therefore composed of two parts:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"A condition that is tested against each node in a graph to choose  which nodes to rewrite.  \nA subgraph that will replace each node selected by the condition  above.","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"In VPL, the condition is split into two components:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"The type of node to be selected (in this example that would be A  or B).  \nA function that is applied to each node in the graph (of the  specified type) to indicate whether the node should be selected or  not. This function is optional (the default is to select every node  of the specified type).","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"The replacement subgraph is specified by a function that takes as input the node selected and returns a subgraph defined as a combination of node objects. Subgraphs (which can also be used as axioms) are created by linearly combining objects that inherit from Node. The operation + implies a linear relationship between two nodes and [] indicates branching.","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"The implementation of the two rules of algae growth model in VPL is as follows:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"rule1 = Rule(A, rhs = x -> A() + B())\r\nrule2 = Rule(B, rhs = x -> A())","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"Note that in each case, the argument rhs is being assigned an anonymous (aka lambda) function. This is a function without a name that is defined directly in the assigment to the argument. That is, the Julia expression x -> A() + B() is equivalent to the following function definition:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"function rule_1(x)\r\n    A() + B()\r\nend","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"For simple rules (especially if the right hand side is just a line of code) it is easier to just define the right hand side of the rule with an anonymous function rather than creating a standalone function with a meaningful name. However, standalone functions are easier to debug as you can call them directly from the REPL.","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"With the axiom and rules we can now create a Graph object that represents the algae organism. The first argument is the axiom and the second is a tuple with all the rewriting rules:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"algae = Graph(axiom, rules = (rule1, rule2))","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"We can visualize the graph by using the function draw(). This will open an external window with an interactive network representation of the current state of the graph:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"draw(algae);","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"You can see that at the moment the graph only contains the axiom, that is, a node of type A. If we apply the rewriting rules iteratively, the graph will grow, in this case representing the growth of the algae organism. The rewriting rules are applied on the graph with the function rewrite!():","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"rewrite!(algae)","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"Since there was only one node of type A, the only rule that was applied was rule1, so the graph should now have two nodes of types A and B, respectively. We can confirm this by drawing the graph.","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"draw(algae);","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"Notice that each node in the network representation is labelled with the type of node (A or B in this case) and a number in parenthesis. This number is a unique identifier associated to each node and it is useful for debugging purposes (this will be explained in more advanced examples).","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"Applying multiple iterations of rewriting can be achieved with a simple loop:","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"for i in 1:4\r\n    rewrite!(algae)\r\nend\r\ndraw(algae);","category":"page"},{"location":"tutorials/algae.html","page":"Algae growth","title":"Algae growth","text":"The network is rather boring as the system is growing linearly (no branching) but it already illustrates how graphs can grow rapidly in just a few iterations. Remember that the interactive visualization allows adjusting the zoom, which is handy when graphs become large.","category":"page"},{"location":"tutorials/random_binary_forest.html#Random-binary-forest","page":"Random binary forest","title":"Random binary forest","text":"","category":"section"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"In this example we extend the binary tree example into a random binary forest, where each tree is described by a separate graph object and parameters driving the growth of these trees vary across individuals following a predefined distribution.","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"The data types, rendering methods and growth rules are the same as in the binary tree example:","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"using VPL\r\n\r\n# Meristem\r\nstruct Meristem <: Node end\r\n# TreeNode\r\nstruct TreeNode <: Node end\r\n# Internode\r\nmutable struct Internode <: Node\r\n  length::Float64\r\nend\r\n\r\nfunction VPL.feedgeom!(turtle::MTurtle, i::Internode)\r\n    HollowCube!(turtle, l = i.length, h =  min(i.length/10, 0.3), w =  min(i.length/10, 0.3), move = true)\r\n    return nothing\r\nend\r\nfunction VPL.feedcolor!(turtle::GLTurtle, i::Internode)\r\n    feedcolor!(turtle, RGB(0,1,0))\r\n    return nothing\r\nend\r\n\r\nrule = Rule(Meristem, rhs = mer -> TreeNode() + (RU(-60.0) + Internode(0.1) + RH(90.0) + Meristem(), \r\n                                                 RU(60.0)  + Internode(0.1) + RH(90.0) + Meristem()))\r\nstruct treeparams\r\n    growth::Float64\r\nend","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"The main difference with respect to the binary tree is that the  growth parameter  will differ across individuals. Also, the starting point of the turtle will differ per individual. To achieve this we need to:","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"(i) Add an additional initial node that moves the turtle to the starting position of each binary tree.","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"(ii) Wrap the axiom rule and the creation of the graph into a function that takes the required parameters as inputs.","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"function create_tree(origin, growth)\r\n    axiom = T(origin) + Internode(0.1) + Meristem()\r\n    tree = Graph(axiom, Tuple(rule), treeparams(growth))\r\n    return tree\r\nend","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"The code for elongating the internodes to simulate growth remains the same as for the binary tree example","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"getInternode = Query(Internode)\r\n\r\nfunction elongate!(tree, query)\r\n    for x in apply(tree, query)\r\n        x.length = x.length*(1.0 + vars(tree).growth)\r\n    end\r\nend\r\n\r\nfunction growth!(tree, query)\r\n    elongate!(tree, query)\r\n    rewrite!(tree)\r\nend\r\n\r\nfunction simulate(tree, query, nsteps)\r\n    new_tree = deepcopy(tree)\r\n    for i in 1:nsteps\r\n        growth!(new_tree, query)\r\n    end\r\n    return new_tree\r\nend","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"Let's simulate a forest of 10 x 10 binary trees with a distance between (and within) rows of 2 meters. First we generate the original positions of the trees. For the position we just need to pass a Vec object with the x, y, and z coordinates of the location of each tree. The code below will generate  a matrix with the coordinates:","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"origins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0]","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"We now simulate the values of the growth parameter, by sampling values for a normal distribution (in practice you would determine this distribution from experiments).  We can implement a function that returns random values with the desired characteristics but take into account that randn implements the standard Normal distribution (so mean = 0 and  standard deviation = 1) so we need to scale it","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"growth_distr(n) = 0.5 .+ randn(n)./10","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"You may also use the Distributions Julia package (you will need to install it first) that allows to construct different distributions and sample from them. For now, let's work with this ad-hoc function but before we use it to generate the growth parameters of the different trees, let's visualize it using the Plots package (as before, you need to install it first if you have not done so already):","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"using Plots\r\nhistogram(growth_distr(10_000))","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"So our trees will have, on average, a relative growth rate of 0.5 (like in the binary tree example) but each individual tree can have any value, mostly between 0.2 and 0.8. Let's generate the growth parameters for the 100 trees in our simulation:","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"growths = growth_distr(100);","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"Now we can create our random forest of binary trees by calling the create_tree function we defined earlier with the correct origins and growth parameter","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"forest = [create_tree(origins[i], growths[i]) for i in 1:100];","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"The object forest contains an array of binary trees. Each tree is a different Graph, with its own nodes, rewriting rules and variables. This avoids having to create a large graphs to include all the plants in a simulation. Below we will run a simulation, first using a sequential approach (i.e. using one core) and then using multiple cores in our computers (please check https://docs.julialang.org/en/v1/manual/multi-threading/ if the different cores are not being used as you may need to change some settings in your computer).","category":"page"},{"location":"tutorials/random_binary_forest.html#Sequential-simulation","page":"Random binary forest","title":"Sequential simulation","text":"","category":"section"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"We can simulate the growth of each tree by applying the method simulate to each tree, creating a new version of the forest (the code below is an array comprehension)","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"newforest = [simulate(tree, getInternode, 2) for tree in forest];","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"And we can render the forest with the function render as in the binary tree example but passing the whole forest at once","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"render(newforest)","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"If we iterate 4 more iterations we will start seeing the different individuals diverging in size due to the differences in growth rates","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"newforest = [simulate(tree, getInternode, 4) for tree in newforest];\r\nrender(newforest)","category":"page"},{"location":"tutorials/random_binary_forest.html#Multithreaded-simulation","page":"Random binary forest","title":"Multithreaded simulation","text":"","category":"section"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"In the previous section, the simulation of growth was done sequentially, one tree after another (since the growth of a tree only depends on its own parameters). However, this can also be executed in multiple threads. In this case we use an explicit loop  and execute the iterations of the loop in multiple threads using the macro @threads. Note that the rendering function can also be ran in parallel (i.e. the geometry will be generated separately for each plant and the merge together):","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"using Base.Threads\r\nnewforest = deepcopy(forest)\r\n@threads for i in 1:length(forest)\r\n    newforest[i] = simulate(forest[i], getInternode, 6)\r\nend\r\nrender(newforest, parallel = true)","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"An alternative way to perform the simulation is to have an outer loop for each timestep and an internal loop over the different trees. Although this approach is not required for this simple model, most FSP models will probably need such a scheme as growth of each individual plant will depend on competition for resources with neighbouring plants. In this case, this approach would look as follows:","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"newforest = deepcopy(forest)\r\nfor step in 1:6\r\n    @threads for i in 1:length(newforest)\r\n        newforest[i] = simulate(newforest[i], getInternode, 1)\r\n    end\r\nend\r\nrender(newforest, parallel = true)","category":"page"},{"location":"tutorials/random_binary_forest.html#Customizing-the-scene","page":"Random binary forest","title":"Customizing the scene","text":"","category":"section"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"Here we are going to customize the scene of our simulation by adding a horizontal tile represting soil and tweaking the 3D representation. When we want to combine plants generated from graphs with any other geometric element it is best to combine all these geometries in a GLScene object. We can start the scene with the newforest generated in the above:","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"scene = GLScene(newforest);","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"We can create the soil tile directly, without having to create a graph. The simplest approach is two use  a special constructor Rectangle where one species a corner of the rectangle and two vectors defining the two sides of the vectors. Both the sides and the corner need to be specified with Vec just like in the above when we determined the origin of each plant. VPL offers some shortcuts: O() returns the origin (Vec(0.0, 0.0, 0.0)), whereas X, Y and Z returns the corresponding axes and you can scale them by  passing the desired length as input. Below, a rectangle is created on the XY plane with the origin as a  corner and each side being 11 units long:","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"soil = Rectangle(O(), Y(21.0), X(21.0)); # (corner, side1, side2)","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"We can now add the soil to the scene object with the add! function.","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"VPL.add!(scene = scene, mesh = soil, color = RGB(1,1,0))","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"We can now render the scene that combines the random forest of binary trees and a yellow soil. Notice that in all previous figures, a coordinate system with grids was being depicted. This is helpful for debugging your code but also to help setup the scene (e.g. if you are not sure how big the soil tile should be). Howver, it may be distracting for the visualization. It turns out that we can turn that off with show_axes = false:","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"render(scene, show_axis = false)","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"We may also want to save a screenshot of the scene. For this, we need to store the output of the render function. We can then resize the window rendering the scene, move around, zoom, etc. When we have a perspective that we like, we can run the save_scene function on the object returned from render. The argument resolution can be adjust in both render and save_nice (the image will have the correct number of pixels but it looks much worse than in the original window...):","category":"page"},{"location":"tutorials/random_binary_forest.html","page":"Random binary forest","title":"Random binary forest","text":"gl_win = render(scene, show_axis = false, resolution = (1920,1080))\r\n# Play around with the scene\r\nsave_scene(\"nice_trees.png\", gl_win, resolution = (1920,1080)) # Should be full HD res","category":"page"},{"location":"tutorials/snowflakes.html#The-Koch-snowflake","page":"The Koch snowflake","title":"The Koch snowflake","text":"","category":"section"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"In this example, we create a Koch snowflake, which is one of the earliest fractals to be described. The Koch snowflake is a closed curve composed on multiple of segments of different lengths. Starting with an equilateral triangle, each segment in the snowflake is replaced by four segments of smaller length arrange in a specific manner. Graphically, the first four iterations of the Koch snowflake construction process result in the following figures (the green segments are shown as guides but they are not part of the snowflake):","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"(Image: First four iterations fo Koch snowflake fractal)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"In order to implement the construction process of a Koch snowflake in VPL we need to understand how a 3D structure can be generated from a graph of nodes. VPL uses a procedural approach to generate of structure based on the concept of turtle graphics.","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"The idea behind this approach is to imagine a turtle located in space with a particular position and orientation. The turtle then starts consuming the different nodes in the graph (following its topological structure) and generates 3D structures as defined by the user for each type of node. The consumption of a node may also include instructions to move and/or rotate the turtle, which allows to alter the relative position of the different 3D structures described by a graph.","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"The construction process of the Koch snowflake in VPL could then be represented by the following axiom and rewriting rule:","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"axiom: E(L) + RU(120) + E(L) + RU(120) + E(L) rule:  E(L) → E(L/3) + RU(-60) + E(L/3) + RU(120) + E(L/3) + RU(-60) + E(L/3)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"Where E represent and edge of a given length (given in parenthesis) and RU represents a rotation of the turtle around the upward axis, with angle of rotation given in parenthesis in hexadecimal degrees. The rule can be visualized as follows:","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"(Image: Koch construction rule)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"Note that VPL already provides several classes for common turtle movements and rotations, so our implementation of the Koch snowflake only needs to define a class to implement the edges of the snowflake. This can be achieved as follows:","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"using VPL\r\nstruct E <: Node\r\n    length::Float64\r\nend","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"Note that nodes of type E need to keep track of the length as illustrated in the above. The axiom is straightforward:","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"const L = 1.0\r\naxiom = E(L) + VPL.RU(120.0) + E(L) + VPL.RU(120.0) + E(L)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"The rule is also straightforward to implement as all the nodes of type E will be replaced in each iteration. However, we need to ensure that the length of the new edges is a calculated from the length of the edge being replaced. In order to extract the data stored in the node being replaced we can simply use the function data. In this case, the replacement function is defined and then added to the rule. This can make the code more readable but helps debugging and testing the replacement function.","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"function Kochsnowflake(x)\r\n    L = data(x).length\r\n    E(L/3) + RU(-60.0) + E(L/3) + RU(120.0) + E(L/3) + RU(-60.0) + E(L/3)\r\n end\r\n rule = Rule(E, rhs = Kochsnowflake)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"The model is then created by constructing the graph","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"Koch = Graph(axiom, rules = Tuple(rule))","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"In order to be able to generate a 3D structure we need to define a method for the function VPL.feedgeom! (notice the need to prefix it with VPL. as we are going to define a method for this function). The method needs to two take two arguments, the first one is always an object of type MTurtle and the second is an object of the type for which the method is defined (in this case, E).","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"The body of the method should generate the 3D structures using the geometry primitives provided by VPL and feed them to the turtle that is being passed to the method as first argument. In this case, we are going to represent the edges of the Koch snowflakes with cylinders, which can be generated with the HollowCylinder! function from VPL. Note that the feedgeom! should return nothing, the turtle will be modified in place (hence the use of ! at the end of the function as customary in the VPL community):","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"function VPL.feedgeom!(turtle::MTurtle, e::E)\r\n    HollowCylinder!(turtle, l = e.length, w = e.length/10, h = e.length/10, move = true)\r\n    return nothing\r\nend","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"Note that the argument move = true indicates that the turtle should move forward as the cylinder is generated a distance equal to the length of the cylinder.","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"With the feedgeom! method defined we can already generate the 3D structure, but we cannot render it yet as we also need to define the color with which to render it. This is achieved by defining the VPL.feedcolor! method that takes a GLTurtle as argument (notice the different data types, MTurtle to collect triangular meshes, GLTurtle to collect colors for rendering). In this case, we just feed a basic RGB color defined by the proportion of red, green and blue. To make the figures more appealing, we can assign random values to each channel of the color to generate random colors.","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"function VPL.feedcolor!(turtle::GLTurtle, e::E)\r\n    feedcolor!(turtle, RGB(rand(), rand(), rand()))\r\n    return nothing\r\nend","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"After defining these two methods, we can now call the function render on the graph to generate a 3D interactive image of the Koch snowflake in the current state","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"render(Koch)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"This renders the initial triangle of the construction procedure of the Koch snowflake. Let's execute the rules once to verify that we get the 2nd iteration (check the figure at the beginning of this document):","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"rewrite!(Koch)\r\nrender(Koch)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"And two more times","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"rewrite!(Koch)\r\nrewrite!(Koch)\r\nrender(Koch)","category":"page"},{"location":"tutorials/snowflakes.html#Other-snowflake-fractals","page":"The Koch snowflake","title":"Other snowflake fractals","text":"","category":"section"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"To demonstrate the power of this approach, let's create an alternative snowflake. We will simply invert the rotations of the turtle in the rewriting rule","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"function Kochsnowflake2(x)\r\n   L = data(x).length\r\n   E(L/3) + RU(60.0)  + E(L/3) + RU(-120.0) + E(L/3) + RU(60.0)   + E(L/3)\r\nend\r\nrule2 = Rule(E, rhs = Kochsnowflake2)\r\nKoch2 = Graph(axiom, rules = Tuple(rule2))","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"The axiom is the same, but now the edges added by the rule will generate the edges towards the inside of the initial triangle. Let's execute the first three iterations and render the results","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"# First iteration\r\nrewrite!(Koch2)\r\nrender(Koch2)\r\n# Second iteration\r\nrewrite!(Koch2)\r\nrender(Koch2)\r\n# Third iteration\r\nrewrite!(Koch2)\r\nrender(Koch2)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"This is know as Koch antisnowflake. We could also easily generate a Cesàro fractal by also changing the axiom:","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"axiomCesaro = E(L) + RU(90.0) + E(L) + RU(90.0) + E(L) + RU(90.0) + E(L)\r\nCesaro = Graph(axiomCesaro, rules = (rule2,))\r\nrender(Cesaro)","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"And, as before, let's go through the first three iterations","category":"page"},{"location":"tutorials/snowflakes.html","page":"The Koch snowflake","title":"The Koch snowflake","text":"# First iteration\r\nrewrite!(Cesaro)\r\nrender(Cesaro)\r\n# Second iteration\r\nrewrite!(Cesaro)\r\nrender(Cesaro)\r\n# Third iteration\r\nrewrite!(Cesaro)\r\nrender(Cesaro)","category":"page"},{"location":"tutorials/binary_tree.html#Binary-tree","page":"Binary tree","title":"Binary tree","text":"","category":"section"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"In this example we build a 3D representation of a binary tree. Although this will not look like a real plant, this example will help introduce additional features of VPL.","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"The model requires three types of nodes:","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"Meristem: These are the nodes responsible for growth of new organs in our binary tree. They contain no data or geometry (i.e. they are a point in the 3D structure).  ","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"Internode: The structural elements that make the binary tree, which is a simple tree made of sticks.  ","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"TreeNode: What is left after a meristem produces a new organ. They contain no data or geometry (so also a point) but are required to keep the branching structure of the tree. Note that we cannot call this data type Node as that is a type already defined by VPL.","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"In a similar fashion to the previous example, internodes are represented by prisms, but unlike before, the length of the prism will change in time, emulating the growth of the tree. For that reason, we need to make the type mutable.","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"The three types of data are defined as follows:","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"using VPL\r\n\r\n# Meristem\r\nstruct Meristem <: Node end\r\n# TreeNode\r\nstruct TreeNode <: Node end\r\n# Internode\r\nmutable struct Internode <: Node\r\n  length::Float64\r\nend","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"As always, the 3D structure and the color of each type of node are implemented with the feedgeom! and feedcolor! methods. In this case, only the internodes have a 3D representation, so these methods are defined for this type only.","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"function VPL.feedgeom!(turtle::MTurtle, i::Internode)\r\n    HollowCube!(turtle, l = i.length, h = i.length/10, w = i.length/10, move = true)\r\n    return nothing\r\nend\r\nfunction VPL.feedcolor!(turtle::GLTurtle, i::Internode)\r\n    feedcolor!(turtle, RGB(0,1,0))\r\n    return nothing\r\nend","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"The growth rule of our binary tree is simple: meristems are replaced a by tree node and two branches that split at specific angles. Each branch is then composed of an internode and ends in a meristem. The two branches are implemented by enclosing with square brackets and separating by commas (like when you create an array of numbers in Julia). Since a binary tree is actually a 2D structure but we want to have it 3D, we add an extra rotation, such that the new branches growing from the apical meristems are not aligned with the preceding internodes. The key is to imagine the turtle in your head and keep track of the different rotations as it moves through the rule. A concept to keep in mind there is that the position and orientation of the turtle is always the same at the beginning of each branch (i.e. essentially, at each branching point, the turtle splits into two clones that move along the tree independently).","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"rule = Rule(Meristem, rhs = mer -> TreeNode() + (RU(-60.0) + Internode(0.1) + RH(90.0) + Meristem(), \r\n                                                 RU(60.0)  + Internode(0.1) + RH(90.0) + Meristem()))","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"In order to simulate growth of the 3D binary tree, we need to define a parameter describing the relative rate at which each internode elongate in each iteration of the simulation. Graphs in VPL can store an object of any user-defined type that will me made accessible to graph rewriting rules and queries. Such object is useful to store parameters (in which case we make them immutable) or state variables that cannot be associated to any specific organ (in which case we would make the object mutable). For this example, we define a data type treeparams that holds the relative growth rate (or growth factor) of the internodes of a tree.","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"struct treeparams\r\n    growth::Float64\r\nend","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"A binary tree initializes as a meristem, so the axiom can be constructed simply as:","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"axiom = Internode(0.1) + Meristem()","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"And the object for the tree can be constructed as before, by passing the axiom and the graph rewriting rules, but in this case also with the object with growth-related parameters.","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"tree = Graph(axiom, Tuple(rule), treeparams(0.5))","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"Note that so far we have not included any code to simulate growth of the internodes. The reason is that, as elongation of internotes does not change the topology of the graph (it simply changes the data stored in certain nodes), this process does not need to be implemented with graph rewriting rules. Instead, we will use a combination of a query (to identify which nodes need to be altered) and direct modification of these nodes. A Query object is a like a Rule but without a right-hand side. In this case, we just want to identify those nodes of type Internode, so we do not need to specify a left-hand side either. Instead, we simply create the query as:","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"getInternode = Query(Internode)","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"If we apply the query to a graph using the apply function, we will get an array of all the nodes that match the query, allow for direct manipulation of their contents. To help organize the code, we will create a function that simulates growth by multiplying the length argument of all internodes in a tree by the growth parameter defined in the above:","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"function elongate!(tree, query)\r\n    for x in apply(tree, query)\r\n        x.length = x.length*(1.0 + vars(tree).growth)\r\n    end\r\nend","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"Note that we use vars on the Graph object to extract the object that was stored inside of it. Also, as this function will modify the graph which is passed as input, we append an ! to the name (this not a special syntax of the language, its just a convention in the Julia community, which is ). Also, in this case, the query object is kept separate from the graph. We could have also store inside the graph like we did for the parameter grow. We could also have packaged the graph and the query into another type representing an individual tree. This is entirely up to the user and indicates that a model can be implemented in many differences ways with VPL.","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"Simulating the growth a tree is a matter of elongating the internodes and applying the rules to create new internodes:","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"function growth!(tree, query)\r\n    elongate!(tree, query)\r\n    rewrite!(tree)\r\nend","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"and a simulation for n steps is achieved with a simple loop:","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"function simulate(tree, query, nsteps)\r\n    new_tree = deepcopy(tree)\r\n    for i in 1:nsteps\r\n        growth!(new_tree, query)\r\n    end\r\n    return new_tree\r\nend","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"Notice that the simulate function creates a copy of the object to avoid overwriting it. If we run the simulation for a couple of steps","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"newtree = simulate(tree, getInternode, 2)","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"The binary tree after two iterations has two branches, as expected:","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"render(newtree)","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"Notice how the lengths of the prisms representing internodes decreases as the branching order increases, as the internodes are younger (i.e. were generated fewer generations ago). Further steps will generate a structure that is more tree-like.","category":"page"},{"location":"tutorials/binary_tree.html","page":"Binary tree","title":"Binary tree","text":"newtree = simulate(newtree, getInternode, 10)\r\nrender(newtree)","category":"page"},{"location":"api/Core.html#Module-Core","page":"Core","title":"Module Core","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"CurrentModule = VPL.Core","category":"page"},{"location":"api/Core.html#Types","page":"Core","title":"Types","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Graph","category":"page"},{"location":"api/Core.html#VPL.Core.Graph","page":"Core","title":"VPL.Core.Graph","text":"Graph(axiom; rules = nothing, vars = nothing)\n\nCreates a dynamic graph defined by the initial node or nodes (axiom), one or more rules  (rules), and an object with graph-level variables (vars). Rules and graph-level variables are optional and must be assigned by keyword (see example below).  Rules must be a Rule or tuple of Rule objects.  The axiom may be a single object inheriting from Node or a subgraph generated  with the graph construction DSL.  A copy of the axiom and rules is always made when constructing the graph, but if object containing graph-level variables is not mutable, the user must manually copy it (with copy or deepcopy) or else changes within the graph will affect the original object (and other graphs created from the same object).\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nno_rules_graph = Graph(axiom)\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\n\n\n\n\n\n","category":"type"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Rule","category":"page"},{"location":"api/Core.html#VPL.Core.Rule","page":"Core","title":"VPL.Core.Rule","text":"Rule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\n\nCreate a replacement rule for nodes of type nodetype with function-like objects for the left-hand side (lhs) and right-hand side (rhs). If the rule captures nodes in the context of the replacement node this must be indicated by the argument captures.\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrewrite!(rules_graph)\n\n\n\n\n\n","category":"type"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Query","category":"page"},{"location":"api/Core.html#VPL.Core.Query","page":"Core","title":"VPL.Core.Query","text":"Query(nodetype::DataType, query = x -> true)\n\nCreate a query that matches nodes of type nodetype and the conditions specified in the argument query (must be a function that returns true). It returns an object of type Query that can be applied to a graph with the function apply.\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\n\n\n\n\n\n","category":"type"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Node","category":"page"},{"location":"api/Core.html#VPL.Core.Node","page":"Core","title":"VPL.Core.Node","text":"Node\n\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL.\n\nExample\n\nstruct bar <: Node\n  x::Int\nend\nb1 = bar(1)\nb2 = bar(2)\nb1 + b2\n\n\n\n\n\n","category":"type"},{"location":"api/Core.html","page":"Core","title":"Core","text":"Context","category":"page"},{"location":"api/Core.html#VPL.Core.Context","page":"Core","title":"VPL.Core.Context","text":"Context\n\nData structure than links a GraphNode to a Graph. Functions data() and vars()  give access to the data stored in the node and graph, respectively. Several  methods are also available to test relationships among nodes in the graph and to  extract these related nodes (see User Manual for details).\n\nUsers do not build Context objects directly but they are provided by VPL as  inputs to the user-defined functions inside rules and queries. \n\n\n\n\n\n","category":"type"},{"location":"api/Core.html#Applying-rules-and-queries","page":"Core","title":"Applying rules and queries","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"apply(g::Graph, query::Query)","category":"page"},{"location":"api/Core.html#VPL.Core.apply-Tuple{VPL.Core.Graph, VPL.Core.Query}","page":"Core","title":"VPL.Core.apply","text":"apply(g::Graph, query::Query)\n\nReturn an array with all the nodes in the graph that match the query supplied by  the user.\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"rewrite!(g::Graph)","category":"page"},{"location":"api/Core.html#VPL.Core.rewrite!-Tuple{VPL.Core.Graph}","page":"Core","title":"VPL.Core.rewrite!","text":"rewrite!(g::Graph)\n\nApply the graph-rewriting rules stored in the graph. This function will match the left-hand sides of the rules against the graph and then replace and/or prune the graph at every location where the left-hand sides matched by the result of executing the right hand side of each rule. The modification is performed in-place, so this function returns nothing.\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrewrite!(rules_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html#Extracting-information","page":"Core","title":"Extracting information","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"vars(g::Graph)","category":"page"},{"location":"api/Core.html#VPL.Core.vars-Tuple{VPL.Core.Graph}","page":"Core","title":"VPL.Core.vars","text":"vars(g::Graph)\n\nReturns the object storing the graph-level variables\n\nExample\n\nstruct A <: Node end\naxiom = A()\ngraph = Graph(axiom, vars = 2)\nvars(graph)\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"rules(g::Graph)","category":"page"},{"location":"api/Core.html#VPL.Core.rules-Tuple{VPL.Core.Graph}","page":"Core","title":"VPL.Core.rules","text":"rules(g::Graph)\n\nReturns a tuple with all the graph-rewriting rules stored in the graph\n\nExample\n\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrules(rules_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"vars(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.vars-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.vars","text":"vars(c::Context)\n\nReturns the object storing the graph-level variables in the graph associated to  a Context object. This needs to be used inside rules and queries.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"data(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.data-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.data","text":"data(c::Context)\n\nReturns the data stored in the node associated to a Context object. This needs to be used inside rules and queries.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html#Graph-traversal","page":"Core","title":"Graph traversal","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"hasParent(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.hasParent-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.hasParent","text":"hasParent(c::Context)\n\nCheck if the node passed as argument has a parent and return true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"isRoot(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.isRoot-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.isRoot","text":"isRoot(c::Context)\n\nCheck if the node passed as argument is the root of the graph (i.e. has no parent)  and return true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"hasAncestor(c::Context, query, maxlevel::Int = typemax(Int))","category":"page"},{"location":"api/Core.html#VPL.Core.hasAncestor","page":"Core","title":"VPL.Core.hasAncestor","text":"hasAncestor(c::Context, condition, maxlevel)\n\nCheck if the node passed as argument has an ancestor that matches the optional  condition and and return true or false and the number of steps taken.  The argument maxlevel is optional and limits the number of steps that the  algorithm will move through the graph (by default there is no limitation). The default condition returns true for any ancestor  and it takes an object of type Context.\n\n\n\n\n\n","category":"function"},{"location":"api/Core.html","page":"Core","title":"Core","text":"parent(c::Context)","category":"page"},{"location":"api/Core.html#Base.parent-Tuple{VPL.Core.Context}","page":"Core","title":"Base.parent","text":"parent(c::Context, nsteps::Int)\n\nReturns a Context object associated to the parent of the node passed as first argument (nsteps = 1, the default) or an ancestor that is nsteps away from the node passed as first argument.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"ancestor(c::Context, query, maxlevel::Int = typemax(Int))","category":"page"},{"location":"api/Core.html#VPL.Core.ancestor","page":"Core","title":"VPL.Core.ancestor","text":"ancestor(c::Context, condition, maxlevel)\n\nReturns a Context object associated to the first ancestor of the node given as  argument that matches the optional condition. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a Context object. The default condition returns true for any ancestor and it takes an object of type Context.\n\n\n\n\n\n","category":"function"},{"location":"api/Core.html","page":"Core","title":"Core","text":"hasChildren(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.hasChildren-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.hasChildren","text":"hasChildren(c::Context)\n\nCheck if the node passed as argument has at least one child and return true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"isLeaf(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.isLeaf-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.isLeaf","text":"isLeaf(c::Context)\n\nCheck if the node passed as argument is a leaf in the graph (i.e. has no children)  and return true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"hasDescendent(c::Context, query, maxlevel::Int = typemax(Int))","category":"page"},{"location":"api/Core.html#VPL.Core.hasDescendent","page":"Core","title":"VPL.Core.hasDescendent","text":"hasDescendent(c::Context, condition, maxlevel)\n\nCheck if the node passed as argument has a descendent that matches the optional condition  and return true or false. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The default condition returns true for any descendent  and it takes an object of type Context.\n\n\n\n\n\n","category":"function"},{"location":"api/Core.html","page":"Core","title":"Core","text":"children(c::Context)","category":"page"},{"location":"api/Core.html#VPL.Core.children-Tuple{VPL.Core.Context}","page":"Core","title":"VPL.Core.children","text":"children(c::Context)\n\nReturns a tuple of Context objects with all the children of the node given as  argument.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"descendent(c::Context, query, maxlevel::Int = typemax(Int))","category":"page"},{"location":"api/Core.html#VPL.Core.descendent","page":"Core","title":"VPL.Core.descendent","text":"descendent(c::Context, condition, maxlevel)\n\nReturns a Context object associated to the first descendent of the node given as  argument that matches the optional condition. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a Context object. The default condition returns true for any descendent and it takes an object of type Context.\n\n\n\n\n\n","category":"function"},{"location":"api/Core.html","page":"Core","title":"Core","text":"traverse(g::Graph, f)","category":"page"},{"location":"api/Core.html#VPL.Core.traverse-Tuple{VPL.Core.Graph, Any}","page":"Core","title":"VPL.Core.traverse","text":"traverse(g::Graph, f)\n\nIterates over all the nodes in the graph (in no particular order) and execute for each node the function f taking as input the data stored in the node.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"traverseDFS(g::Graph, f)","category":"page"},{"location":"api/Core.html#VPL.Core.traverseDFS-Tuple{VPL.Core.Graph, Any}","page":"Core","title":"VPL.Core.traverseDFS","text":"traverseDFS(g::Graph, f)\n\nIterates over all the nodes in the graph (depth-first order, starting at the  root of the graph) and execute for each node the function f taking as input the  data stored in the node.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"traverseBFS(g::Graph, f)","category":"page"},{"location":"api/Core.html#VPL.Core.traverseBFS-Tuple{VPL.Core.Graph, Any}","page":"Core","title":"VPL.Core.traverseBFS","text":"traverseBFS(g::Graph, f)\n\nIterates over all the nodes in the graph (breadth-first order, starting at the  root of the graph) and execute for each node the function f taking as input the  data stored in the node.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html#Graph-visualization","page":"Core","title":"Graph visualization","text":"","category":"section"},{"location":"api/Core.html","page":"Core","title":"Core","text":"draw(g::Graph; name::String = \"VPL Graph\")","category":"page"},{"location":"api/Core.html#VPL.Core.draw-Tuple{VPL.Core.Graph}","page":"Core","title":"VPL.Core.draw","text":"draw(g::Graph; name::String = \"VPL Graph\")\n\nDraw a network representation of the graph. The drawing is performed on a Blink window using the vis.js Javascript library. The function returns the handler to the Blink window. Access to Internet is required as the libraries are loaded from a cdns server.\n\n\n\n\n\n","category":"method"},{"location":"api/Core.html","page":"Core","title":"Core","text":"get_id(key, data)","category":"page"},{"location":"api/Core.html#VPL.Core.get_id-Tuple{Any, Any}","page":"Core","title":"VPL.Core.get_id","text":"get_id(key, data)\n\nMethod that defines the label associated to the node data when drawing the graph. The argument key is the unique identifier of the node in the graph. The default method prints the type of data stored in the node and the unique identifier of the node in parenthesis.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Virtual-Plant-Laboratory","page":"Introduction","title":"Virtual Plant Laboratory","text":"","category":"section"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The Virtual Plant Laboratory (VPL) is a Julia package that aids in the construction,  simulation and visualization of functional-structural plant models (FSPM). VPL  is not a standalone solution to all the computational problems relevant to FSPM,  but rather it focuses on those algorithms and visualizations that are specific to  FSPM and for which there are no good solutions in the Julia package ecosystem.  Furthermore, VPL is 100% written in Julia and therefore VPL will work in any  platform and with any code editor where Julia works. Finally, VPL does not offer  a domain specific language for FSPM but rather it allows building FSP models by  creating user-defined data types  and methods.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"There is no standard definition of what an  FSPM is, though these models will  always involve some combination of plant structure and function, so it is likely  that VPL will not be useful with every possible FSPM. Instead, VPL focuses on  models that represent indivudual plants as graphs of elements (usually organs)  that interact with each other and with the environment. In a typical VPL model,  each plant is represented by its own graph which can change dynamically through  the iterative application of graph rewriting rules. Based on this goal, what VPL  offers mainly are data structures and algorithms that allow ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"modelling dynamic graphs that represent plants,  \nmodelling the interaction between plants and their 3D environment by generating 3D structures from the graphs and simulating capture of different resources (e.g. light) and \nmodelling the interaction among elements within each plant by constructing  dynamic networks that represent systems of ordinary differential equations. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"In terms of design, VPL gives priority to performance and simple interfaces as opposed to complex layers of abstraction. This implies that models in VPL may be more verbose and procedural (as opposed to descriptive) than in other FSPM platforms, while being more transparent and easier to follow.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"VPL requires using Julia version 1.6 or higher. The installation of VPL is as easy as running the following code:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(PackageSpec(url = \"https://git.wur.nl/vpl/vpl.git\", rev  = \"master\"))","category":"page"},{"location":"index.html#The-VPL-ecosystem","page":"Introduction","title":"The VPL ecosystem","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The package VPL contains all the basic functionality to build FSPM but, as  indicated earlier, the emphasis is on minimal, simple and transparent interfaces. In order to facilitate the construction of advanced FSPM, an ecosystem of  packages will be built around VPL that bring higher levels of abstraction and  reusable components with which models can be built.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The packages currently planned include","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Ecophys: Algorithms and data structures to simulate ecophysiological processes including photosynthesis, transpiration, leaf energy balance, phenology, respiration, nutrient and water uptake, etc.\nSky: Algorithms to simulate different sky conditions in terms of the intensity of solar radiation and its spatial distribution.\nGCIM: A generic model that allows simulating multiple types of crops with an emphasis on interactions among crops","category":"page"},{"location":"index.html#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for VPL is provided in this website in four formats:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"User manual\nTutorials and examples\nAPI\nTechnical notes","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"New users are expected to start with the tutorials and consult the user manual to understand better the different concepts used in VPL and get an overview of the different options available. The API documentation describes each individual  function and data type, with an emphasis on inputs and outputs and (in addition  to this website) it can be accessed from within Julia with ? (see the section  Accessing Documentation  in the Julia manual). The developer manual is useful for people who want to  understand the internal details of VPL and how different algorithms are  implemented (i.e. the developer manual should be seen as a supplementary to the source code of VPL).","category":"page"}]
}
