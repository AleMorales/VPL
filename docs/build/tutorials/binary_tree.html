<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Binary tree · VPL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">VPL.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">User Manual</span><ul><li><a class="tocitem" href="../manual/VPL.html">Dynamic graph creation and manipulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="algae.html">Algae growth</a></li><li><a class="tocitem" href="relational_queries.html">Relational queries</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/Core.html">Core</a></li></ul></li><li><span class="tocitem">Technical Notes</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="binary_tree.html">Binary tree</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="binary_tree.html">Binary tree</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AleMorales/VPL.jl/blob/master/docs/src/tutorials/binary_tree.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Binary-tree"><a class="docs-heading-anchor" href="#Binary-tree">Binary tree</a><a id="Binary-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-tree" title="Permalink"></a></h1><p>In this example we build a 3D representation of a binary tree. Although this will not look like a real plant, this example will help introduce additional features of VPL.</p><p>The model requires three types of nodes:</p><p><em>Meristem</em>: These are the nodes responsible for growth of new organs in our binary tree. They contain no data or geometry (i.e. they are a point in the 3D structure).  </p><p><em>Internode</em>: The structural elements that make the binary tree, which is a simple tree made of sticks.  </p><p><em>TreeNode</em>: What is left after a meristem produces a new organ. They contain no data or geometry (so also a point) but are required to keep the branching structure of the tree. Note that we cannot call this data type <code>Node</code> as that is a type already defined by VPL.</p><p>In a similar fashion to the previous example, internodes are represented by prisms, but unlike before, the length of the prism will change in time, emulating the growth of the tree. For that reason, we need to make the type mutable.</p><p>The three types of data are defined as follows:</p><pre><code class="language-julia hljs">using VPL

# Meristem
struct Meristem &lt;: Node end
# TreeNode
struct TreeNode &lt;: Node end
# Internode
mutable struct Internode &lt;: Node
  length::Float64
end</code></pre><p>As always, the 3D structure and the color of each type of node are implemented with the <code>feedgeom!</code> and <code>feedcolor!</code> methods. In this case, only the internodes have a 3D representation, so these methods are defined for this type only.</p><pre><code class="language-julia hljs">function VPL.feedgeom!(turtle::MTurtle, i::Internode)
    HollowCube!(turtle, l = i.length, h = i.length/10, w = i.length/10, move = true)
    return nothing
end
function VPL.feedcolor!(turtle::GLTurtle, i::Internode)
    feedcolor!(turtle, RGB(0,1,0))
    return nothing
end</code></pre><p>The growth rule of our binary tree is simple: meristems are replaced a by tree node and two branches that split at specific angles. Each branch is then composed of an internode and ends in a meristem. The two branches are implemented by enclosing with square brackets and separating by commas (like when you create an array of numbers in Julia). Since a binary tree is actually a 2D structure but we want to have it 3D, we add an extra rotation, such that the new branches growing from the apical meristems are not aligned with the preceding internodes. The key is to imagine the turtle in your head and keep track of the different rotations as it moves through the rule. A concept to keep in mind there is that the position and orientation of the turtle is always the same at the beginning of each branch (i.e. essentially, at each branching point, the turtle splits into two clones that move along the tree independently).</p><pre><code class="language-julia hljs">rule = Rule(Meristem, rhs = mer -&gt; TreeNode() + (RU(-60.0) + Internode(0.1) + RH(90.0) + Meristem(), 
                                                 RU(60.0)  + Internode(0.1) + RH(90.0) + Meristem()))</code></pre><p>In order to simulate growth of the 3D binary tree, we need to define a parameter describing the relative rate at which each internode elongate in each iteration of the simulation. Graphs in VPL can store an object of any user-defined type that will me made accessible to graph rewriting rules and queries. Such object is useful to store parameters (in which case we make them immutable) or state variables that cannot be associated to any specific organ (in which case we would make the object mutable). For this example, we define a data type <code>treeparams</code> that holds the relative growth rate (or growth factor) of the internodes of a tree.</p><pre><code class="language-julia hljs">struct treeparams
    growth::Float64
end</code></pre><p>A binary tree initializes as a meristem, so the axiom can be constructed simply as:</p><pre><code class="language-julia hljs">axiom = Internode(0.1) + Meristem()</code></pre><p>And the object for the tree can be constructed as before, by passing the axiom and the graph rewriting rules, but in this case also with the object with growth-related parameters.</p><pre><code class="language-julia hljs">tree = Graph(axiom, Tuple(rule), treeparams(0.5))</code></pre><p>Note that so far we have not included any code to simulate growth of the internodes. The reason is that, as elongation of internotes does not change the topology of the graph (it simply changes the data stored in certain nodes), this process does not need to be implemented with graph rewriting rules. Instead, we will use a combination of a query (to identify which nodes need to be altered) and direct modification of these nodes. A <code>Query</code> object is a like a <code>Rule</code> but without a right-hand side. In this case, we just want to identify those nodes of type <code>Internode</code>, so we do not need to specify a left-hand side either. Instead, we simply create the query as:</p><pre><code class="language-julia hljs">getInternode = Query(Internode)</code></pre><p>If we apply the query to a graph using the <code>apply</code> function, we will get an array of all the nodes that match the query, allow for direct manipulation of their contents. To help organize the code, we will create a function that simulates growth by multiplying the <code>length</code> argument of all internodes in a tree by the <code>growth</code> parameter defined in the above:</p><pre><code class="language-julia hljs">function elongate!(tree, query)
    for x in apply(tree, query)
        x.length = x.length*(1.0 + vars(tree).growth)
    end
end</code></pre><p>Note that we use <code>vars</code> on the <code>Graph</code> object to extract the object that was stored inside of it. Also, as this function will modify the graph which is passed as input, we append an <code>!</code> to the name (this not a special syntax of the language, its just a convention in the Julia community, which is ). Also, in this case, the query object is kept separate from the graph. We could have also store inside the graph like we did for the parameter <code>grow</code>. We could also have packaged the graph and the query into another type representing an individual tree. This is entirely up to the user and indicates that a model can be implemented in many differences ways with VPL.</p><p>Simulating the growth a tree is a matter of elongating the internodes and applying the rules to create new internodes:</p><pre><code class="language-julia hljs">function growth!(tree, query)
    elongate!(tree, query)
    rewrite!(tree)
end</code></pre><p>and a simulation for n steps is achieved with a simple loop:</p><pre><code class="language-julia hljs">function simulate(tree, query, nsteps)
    new_tree = deepcopy(tree)
    for i in 1:nsteps
        growth!(new_tree, query)
    end
    return new_tree
end</code></pre><p>Notice that the <code>simulate</code> function creates a copy of the object to avoid overwriting it. If we run the simulation for a couple of steps</p><pre><code class="language-julia hljs">newtree = simulate(tree, getInternode, 2)</code></pre><p>The binary tree after two iterations has two branches, as expected:</p><pre><code class="language-julia hljs">render(newtree)</code></pre><p>Notice how the lengths of the prisms representing internodes decreases as the branching order increases, as the internodes are younger (i.e. were generated fewer generations ago). Further steps will generate a structure that is more tree-like.</p><pre><code class="language-julia hljs">newtree = simulate(newtree, getInternode, 10)
render(newtree)</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 11 April 2022 15:23">Monday 11 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
