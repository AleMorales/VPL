<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Koch snowflake · VPL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">VPL.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">User Manual</span><ul><li><a class="tocitem" href="../manual/VPL.html">Dynamic graph creation and manipulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="algae.html">Algae growth</a></li><li><a class="tocitem" href="relational_queries.html">Relational queries</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/Core.html">Core</a></li></ul></li><li><span class="tocitem">Technical Notes</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="snowflakes.html">The Koch snowflake</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="snowflakes.html">The Koch snowflake</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AleMorales/VPL.jl/blob/master/docs/src/tutorials/snowflakes.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Koch-snowflake"><a class="docs-heading-anchor" href="#The-Koch-snowflake">The Koch snowflake</a><a id="The-Koch-snowflake-1"></a><a class="docs-heading-anchor-permalink" href="#The-Koch-snowflake" title="Permalink"></a></h1><p>In this example, we create a Koch snowflake, which is one of the earliest fractals to be described. The Koch snowflake is a closed curve composed on multiple of segments of different lengths. Starting with an equilateral triangle, each segment in the snowflake is replaced by four segments of smaller length arrange in a specific manner. Graphically, the first four iterations of the Koch snowflake construction process result in the following figures (the green segments are shown as guides but they are not part of the snowflake):</p><p><img src="KochWikipedia.png" alt="First four iterations fo Koch snowflake fractal"/></p><p>In order to implement the construction process of a Koch snowflake in VPL we need to understand how a 3D structure can be generated from a graph of nodes. VPL uses a procedural approach to generate of structure based on the concept of turtle graphics.</p><p>The idea behind this approach is to imagine a turtle located in space with a particular position and orientation. The turtle then starts consuming the different nodes in the graph (following its topological structure) and generates 3D structures as defined by the user for each type of node. The consumption of a node may also include instructions to move and/or rotate the turtle, which allows to alter the relative position of the different 3D structures described by a graph.</p><p>The construction process of the Koch snowflake in VPL could then be represented by the following axiom and rewriting rule:</p><p>axiom: E(L) + RU(120) + E(L) + RU(120) + E(L) rule:  E(L) → E(L/3) + RU(-60) + E(L/3) + RU(120) + E(L/3) + RU(-60) + E(L/3)</p><p>Where E represent and edge of a given length (given in parenthesis) and RU represents a rotation of the turtle around the upward axis, with angle of rotation given in parenthesis in hexadecimal degrees. The rule can be visualized as follows:</p><p><img src="Koch_order_1.png" alt="Koch construction rule"/></p><p>Note that VPL already provides several classes for common turtle movements and rotations, so our implementation of the Koch snowflake only needs to define a class to implement the edges of the snowflake. This can be achieved as follows:</p><pre><code class="language-julia hljs">using VPL
struct E &lt;: Node
    length::Float64
end</code></pre><p>Note that nodes of type E need to keep track of the length as illustrated in the above. The axiom is straightforward:</p><pre><code class="language-julia hljs">const L = 1.0
axiom = E(L) + VPL.RU(120.0) + E(L) + VPL.RU(120.0) + E(L)</code></pre><p>The rule is also straightforward to implement as all the nodes of type E will be replaced in each iteration. However, we need to ensure that the length of the new edges is a calculated from the length of the edge being replaced. In order to extract the data stored in the node being replaced we can simply use the function data. In this case, the replacement function is defined and then added to the rule. This can make the code more readable but helps debugging and testing the replacement function.</p><pre><code class="language-julia hljs">function Kochsnowflake(x)
    L = data(x).length
    E(L/3) + RU(-60.0) + E(L/3) + RU(120.0) + E(L/3) + RU(-60.0) + E(L/3)
 end
 rule = Rule(E, rhs = Kochsnowflake)</code></pre><p>The model is then created by constructing the graph</p><pre><code class="language-julia hljs">Koch = Graph(axiom, rules = Tuple(rule))</code></pre><p>In order to be able to generate a 3D structure we need to define a method for the function <code>VPL.feedgeom!</code> (notice the need to prefix it with <code>VPL.</code> as we are going to define a method for this function). The method needs to two take two arguments, the first one is always an object of type MTurtle and the second is an object of the type for which the method is defined (in this case, E).</p><p>The body of the method should generate the 3D structures using the geometry primitives provided by VPL and feed them to the turtle that is being passed to the method as first argument. In this case, we are going to represent the edges of the Koch snowflakes with cylinders, which can be generated with the <code>HollowCylinder!</code> function from VPL. Note that the <code>feedgeom!</code> should return <code>nothing</code>, the turtle will be modified in place (hence the use of <code>!</code> at the end of the function as customary in the VPL community):</p><pre><code class="language-julia hljs">function VPL.feedgeom!(turtle::MTurtle, e::E)
    HollowCylinder!(turtle, l = e.length, w = e.length/10, h = e.length/10, move = true)
    return nothing
end</code></pre><p>Note that the argument <code>move = true</code> indicates that the turtle should move forward as the cylinder is generated a distance equal to the length of the cylinder.</p><p>With the <code>feedgeom!</code> method defined we can already generate the 3D structure, but we cannot render it yet as we also need to define the color with which to render it. This is achieved by defining the <code>VPL.feedcolor!</code> method that takes a <code>GLTurtle</code> as argument (notice the different data types, <code>MTurtle</code> to collect triangular meshes, <code>GLTurtle</code> to collect colors for rendering). In this case, we just feed a basic <code>RGB</code> color defined by the proportion of red, green and blue. To make the figures more appealing, we can assign random values to each channel of the color to generate random colors.</p><pre><code class="language-julia hljs">function VPL.feedcolor!(turtle::GLTurtle, e::E)
    feedcolor!(turtle, RGB(rand(), rand(), rand()))
    return nothing
end</code></pre><p>After defining these two methods, we can now call the function render on the graph to generate a 3D interactive image of the Koch snowflake in the current state</p><pre><code class="language-julia hljs">render(Koch)</code></pre><p>This renders the initial triangle of the construction procedure of the Koch snowflake. Let&#39;s execute the rules once to verify that we get the 2nd iteration (check the figure at the beginning of this document):</p><pre><code class="language-julia hljs">rewrite!(Koch)
render(Koch)</code></pre><p>And two more times</p><pre><code class="language-julia hljs">rewrite!(Koch)
rewrite!(Koch)
render(Koch)</code></pre><h1 id="Other-snowflake-fractals"><a class="docs-heading-anchor" href="#Other-snowflake-fractals">Other snowflake fractals</a><a id="Other-snowflake-fractals-1"></a><a class="docs-heading-anchor-permalink" href="#Other-snowflake-fractals" title="Permalink"></a></h1><p>To demonstrate the power of this approach, let&#39;s create an alternative snowflake. We will simply invert the rotations of the turtle in the rewriting rule</p><pre><code class="language-julia hljs">function Kochsnowflake2(x)
   L = data(x).length
   E(L/3) + RU(60.0)  + E(L/3) + RU(-120.0) + E(L/3) + RU(60.0)   + E(L/3)
end
rule2 = Rule(E, rhs = Kochsnowflake2)
Koch2 = Graph(axiom, rules = Tuple(rule2))</code></pre><p>The axiom is the same, but now the edges added by the rule will generate the edges towards the inside of the initial triangle. Let&#39;s execute the first three iterations and render the results</p><pre><code class="language-julia hljs"># First iteration
rewrite!(Koch2)
render(Koch2)
# Second iteration
rewrite!(Koch2)
render(Koch2)
# Third iteration
rewrite!(Koch2)
render(Koch2)</code></pre><p>This is know as <a href="https://mathworld.wolfram.com/KochAntisnowflake.html">Koch antisnowflake</a>. We could also easily generate a <a href="https://mathworld.wolfram.com/CesaroFractal.html">Cesàro fractal</a> by also changing the axiom:</p><pre><code class="language-julia hljs">axiomCesaro = E(L) + RU(90.0) + E(L) + RU(90.0) + E(L) + RU(90.0) + E(L)
Cesaro = Graph(axiomCesaro, rules = (rule2,))
render(Cesaro)</code></pre><p>And, as before, let&#39;s go through the first three iterations</p><pre><code class="language-julia hljs"># First iteration
rewrite!(Cesaro)
render(Cesaro)
# Second iteration
rewrite!(Cesaro)
render(Cesaro)
# Third iteration
rewrite!(Cesaro)
render(Cesaro)</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 11 April 2022 15:23">Monday 11 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
