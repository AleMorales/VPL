### This file contains public API ###

################################################################################
############################  StaticGraph traversal  ###########################
################################################################################

"""
    traverse(g::Graph; fun = () -> nothing)

Iterates over all the nodes in the graph and execute for the function `fun` on
each node

## Arguments
- `g::Graph`: The graph object that will be traversed.
- `fun`: A function or function-like object defined by the user that will be
applied to each node. This argument is assigned by keyword.

## Details
This traveral happens in the order in which the nodes are stored in the graph.
This order is arbitrary and may vary across executions of the code (it does not
correspond to the order in which nodes are created). For algorithms that require
a particular traveral order of the graph, see `traverseDFS` and `traverseBFS`.

This function does not store any results generated by `fun`. Hence, if the user
wants to keep track of such results, they should be stored indirectly (e.g., via
a global variable or internally by creating a functor).

The function or function-like object provided by the user should take only one
argument that corresponds to applying `data()` to each node in the graph. Several
methods of such function may be defined for different types of nodes in the
graph. Since the function will use the data stored in the nodes, relations among
nodes may not be used as input. For algorithms where relations among nodes are
important, the user should be using queries instead (see `Query` and general VPL
documentation).

## Return
This function returns nothing but `fun` may have side-effects.

## Examples
```julia
let
    struct A1 <: Node val::Int end
    struct B1 <: Node val::Int end
    struct Foo
        vals::Vector{Int}
    end
    function (f::Foo)(x)
        push!(f.vals, x.val)
    end
    f = Foo(Int[])
    axiom = A1(2) + (B1(1) + A1(3), B1(4))
    g = Graph(axiom = axiom)
    traverse(g, fun = f)
    f.vals
end
```
"""
traverse(g::Graph; fun = () -> nothing) = traverse(graph(g), fun)
function traverse(g::StaticGraph, fun)
    for val in values(nodes(g))
        fun(data(val))
    end
    return nothing
end

"""
    traverseDFS(g::Graph; fun = () -> nothing, ID = root(g))

Iterates over all the nodes in the graph (depth-first order, starting at a any
node) and execute for the function `fun` on each node

## Arguments
- `g::Graph`: The graph object that will be traversed.
- `fun`: A function or function-like object defined by the user that will be
applied to each node. This argument is assigned by keyword.
- `ID`: The ID of the node where the traveral should start. This argument is
assigned by keyword and is, by default, the root of the graph.

## Details
This traveral happens in a depth-first order. That is, all nodes in a branch of
the graph are visited until reach a leaf node, then moving to the next branch.
Hence, this algorithm should always generate the same result when applied to the
same graph (assuming the user-defined function is not stochastic). For a version
of this function that us breadth-first order see `traverseBFS`.

This function does not store any results generated by `fun`. Hence, if the user
wants to keep track of such results, they should be stored indirectly (e.g., via
a global variable or internally by creating a functor).

The function or function-like object provided by the user should take only one
argument that corresponds to applying `data()` to each node in the graph. Several
methods of such function may be defined for different types of nodes in the
graph. Since the function will use the data stored in the nodes, relations among
nodes may not be used as input. For algorithms where relations among nodes are
important, the user should be using queries instead (see `Query` and general VPL
documentation).

## Return
This function returns nothing but `fun` may have side-effects.

## Examples
```julia
let
    struct A1 <: Node val::Int end
    struct B1 <: Node val::Int end
    struct Foo
        vals::Vector{Int}
    end
    function (f::Foo)(x)
        push!(f.vals, x.val)
    end
    f = Foo(Int[])
    axiom = A1(2) + (B1(1) + A1(3), B1(4))
    g = Graph(axiom = axiom)
    traverseDFS(g, fun = f)
    f.vals
end
```
"""
traverseDFS(g::Graph; fun = () -> nothing, ID = root(g)) = 
                                                  traverseDFS(graph(g), fun, ID)

function traverseDFS(g::StaticGraph, fun, ID)
    # Use LIFO stack to keep track of nodes in traversal
    nodeStack = Int[]
    push!(nodeStack, ID)
    # Iterate over all nodes in the graph
    while(length(nodeStack) > 0)
        # Always execute f on the last node added
        ID = pop!(nodeStack)
        fun(data(g[ID]))
        # Add the children to the stack (if any)
        for childID in childrenID(g[ID])
            push!(nodeStack, childID)
        end
    end
    return nothing
end

"""
    traverseBFS(g::Graph; fun = () -> nothing, ID = root(g))

Iterates over all the nodes in the graph (breadth-first order, starting at a any
node) and execute for the function `fun` on each node

## Arguments
- `g::Graph`: The graph object that will be traversed.
- `fun`: A function or function-like object defined by the user that will be
applied to each node. This argument is assigned by keyword.
- `ID`: The ID of the node where the traveral should start. This argument is
assigned by keyword and is, by default, the root of the graph.

## Details
This traveral happens in a breadth-first order. That is, all nodes at a given
depth of the the graph are visited first, then moving on to the next level.
Hence, this algorithm should always generate the same result when applied to the
same graph (assuming the user-defined function is not stochastic). For a version
of this function that us depth-first order see `traverseDFS`.

This function does not store any results generated by `fun`. Hence, if the user
wants to keep track of such results, they should be stored indirectly (e.g., via
a global variable or internally by creating a functor).

The function or function-like object provided by the user should take only one
argument that corresponds to applying `data()` to each node in the graph. Several
methods of such function may be defined for different types of nodes in the
graph. Since the function will use the data stored in the nodes, relations among
nodes may not be used as input. For algorithms where relations among nodes are
important, the user should be using queries instead (see `Query` and general VPL
documentation).

## Return
This function returns nothing but `fun` may have side-effects.

## Examples
```julia
let
    struct A1 <: Node val::Int end
    struct B1 <: Node val::Int end
    struct Foo
        vals::Vector{Int}
    end
    function (f::Foo)(x)
        push!(f.vals, x.val)
    end
    f = Foo(Int[])
    axiom = A1(2) + (B1(1) + A1(3), B1(4))
    g = Graph(axiom = axiom)
    traverseBFS(g, fun = f)
    f.vals
end
```
"""
traverseBFS(g::Graph; fun = () -> nothing, ID = root(g)) = 
                                                  traverseBFS(graph(g), fun, ID)
function traverseBFS(g::StaticGraph, fun, ID)
    # Use LIFO stack to keep track of nodes in traversal
    nodeStack = Int[]
    prepend!(nodeStack, ID)
    # Iterate over all nodes in the graph
    while(length(nodeStack) > 0)
        # Always execute f on the last node added
        ID = pop!(nodeStack)
        fun(data(g[ID]))
        # Add the children to the stack (if any)
        for childID in childrenID(g[ID])
            prepend!(nodeStack, childID)
        end
    end
end